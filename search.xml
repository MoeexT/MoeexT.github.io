<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[FancyToys 开发笔记]]></title>
    <url>%2F2020%2F09%2F30%2Ffancy-toys-notes%2F</url>
    <content type="text"><![CDATA[FancyToys是一个工具集，里边包含了Nursery。 UWP 大佬 FancyToys问题同时创建了多个ContentDialog System.Exception:“某个异步操作没有正常启动。 Only a single ContentDialog can be open at any time.” 1234567891011public static async void Show(string title) &#123; ContentDialog dialog = new ContentDialog() &#123; Title = title, PrimaryButtonText = "好的", CloseButtonText = "Cancel", DefaultButton = ContentDialogButton.Primary, &#125;; await dialog.ShowAsync(); &#125; Utils.csStackOverFlow1234567891011121314151617181920212223242526272829303132333435363738public class DialogUtil{ public static ContentDialog ActiveDialog; static TaskCompletionSource DialogAwaiter = new TaskCompletionSource(); public static async void CreateContentDialog(ContentDialog Dialog, bool awaitPreviousDialog) { await CreateDialog(Dialog, awaitPreviousDialog); } public static async Task CreateContentDialogAsync(ContentDialog Dialog, bool awaitPreviousDialog) { await CreateDialog(Dialog, awaitPreviousDialog); } private static void ActiveDialog_Closed(ContentDialog sender, ContentDialogClosedEventArgs args) { DialogAwaiter.SetResult(true); } public static async void Info(string text) { await DialogUtil.CreateContentDialogAsync(new ContentDialog { Title = "Info", Content = new TextBlock { Text = text, TextWrapping = TextWrapping.Wrap }, PrimaryButtonText = "好的" }, awaitPreviousDialog: true); } static async Task CreateDialog(ContentDialog Dialog, bool awaitPreviousDialog) { if (ActiveDialog != null) { if (awaitPreviousDialog) { await DialogAwaiter.Task; DialogAwaiter = new TaskCompletionSource(); } else ActiveDialog.Hide(); } ActiveDialog = Dialog; ActiveDialog.Closed += ActiveDialog_Closed; await ActiveDialog.ShowAsync(); ActiveDialog.Closed -= ActiveDialog_Closed; }} 启动进程失败 Stackoverflow1（未成功） Stackoverflow方式2（有思路） System.ComponentModel.Win32Exception:“拒绝访问。” UWP拒绝直接启动进程，只能想办法绕过这个限制； 解决思路： 经Stackoverflow方式2（有思路）的开导，现已经可以用这个方式启动特定进程。但该方式是硬编码，必须在FancyToys编译的时候把所需的app的路径加进去，自己用的话还可以接受，但是给别人用的话肯定行不通。此外，启动器打开时有黑框（闪一下），这可不行。 这里边有了app启动器，可以把小黑框去掉，监听FancyToys发送的请求，根据请求内容启动相应的app。通信内容包含app路径、运行参数等内容。 UWP-客户端，启动器-服务端。做了一个简单的服务器：NurseryLauncher.exe，可以接收到start/stop的指令，根据指令做相应操作；启动进程后每隔一段时间向客户端发送进程消息。 DataGrid的更新这是最后一个困扰人的问题了 功能与插件可拖拽区域 UWP拖拽文件 bilibili-添加拖拽 和WPF不太一样。与之相比较，出现了两个小问题： 一开始没有实现DragOver，误以为不能拖拽，实际上可能已经OK了 Rectangle没有Fill属性的话不能拖拽，但可以设置Opacity解决。添加了颜色之后甚至比之前好看。 123456789101112131415161718192021222324252627282930private async void DropArea_Drop(object sender, DragEventArgs e)&#123; var defer = e.GetDeferral(); try &#123; DataPackageView dpv = e.DataView; if (dpv.Contains(StandardDataFormats.StorageItems)) &#123; List&lt;StorageFile&gt; fileList = new List&lt;StorageFile&gt;(); var files = await dpv.GetStorageItemsAsync(); foreach (var item in files) &#123; DialogUtil.Info(item.Name); &#125; &#125; &#125; finally &#123; defer.Complete(); &#125;&#125;private void DropArea_DragOver(object sender, DragEventArgs e)&#123; e.AcceptedOperation = DataPackageOperation.Copy; e.DragUIOverride.Caption = "拖放以添加"; e.DragUIOverride.IsCaptionVisible = true; e.DragUIOverride.IsContentVisible = true; e.DragUIOverride.IsGlyphVisible = true; e.Handled = true;&#125; ToggleSwitchList当我一开始想做一个ToggleSwitchList的时候，每一个开关都有右键列表，这里给出了一个可行的解决方案，绑定的数据源是ObservableCollection。之后发现开关有一个被覆盖的问题：后台代码已经设定好了属性，绑定好了事件，到了这里被模板的ToggleSwitch覆盖了，全部变成了xaml设置的样式。可行方案变得不可行。 123456789101112131415&lt;ListBox x:Name="ProcessListBox" Margin="0,0,0,10" Width="150" Background="&#123;ThemeResource BackgroundAcrylicBrush&#125;" ItemsSource="&#123;Binding SwitchList&#125;" &gt; &lt;!-- &lt;ListBox.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;ToggleSwitch&gt; &lt;FlyoutBase.AttachedFlyout&gt; &lt;MenuFlyout&gt; &lt;MenuFlyoutItem/&gt; &lt;MenuFlyoutItem/&gt; &lt;/MenuFlyout&gt; &lt;/FlyoutBase.AttachedFlyout&gt; &lt;/ToggleSwitch&gt; &lt;/DataTemplate&gt; &lt;/ListBox.ItemTemplate&gt; --&gt;&lt;/ListBox&gt; 后来就回归原始，不绑定数据源，直接调用ProcessListBox.Items.Add方法，删除的时候使用Remove方法，问题解决了一半，然后是绑定右键菜单。在页面添加资源字典，ToggleSwitch绑定RightTapped事件（一开始在设计页面找的是”RightClick”事件），问题迎刃而解。 123456&lt;Page.Resources&gt; &lt;muxc:CommandBarFlyout Placement="Right" x:Name="CommandFlyout" ShowMode="Transient"&gt; &lt;AppBarButton Label="Args" Icon="Attach" Click="AppBarArgsButton_Click" ToolTipService.ToolTip="添加参数" /&gt; &lt;AppBarButton Label="Delete" Icon="Delete" Click="AppBarDeleteButton_Click" ToolTipService.ToolTip="删除" /&gt; &lt;/muxc:CommandBarFlyout&gt;&lt;/Page.Resources&gt; ContentDialog输入框来自 这里 解决方案资源管理器可以添加内容对话框（ContentDialog）页面！ 可能是因为对话框不能直接返回输入值，这里用了公开变量的方法。isSaved用于表明是否保存输入，inputArgs用于保存输入值。关闭或取消对话框之后，就可以根据上述两个变量进行相应的操作。感谢提出这个方法的作者。 1234567891011121314public bool isSaved = false;public string inputArgs = "";private void ContentDialog_PrimaryButtonClick(ContentDialog sender, ContentDialogButtonClickEventArgs args)&#123; inputArgs = DialogInput.Text; isSaved = true; Hide();&#125;private void ContentDialog_SecondaryButtonClick(ContentDialog sender, ContentDialogButtonClickEventArgs args)&#123; isSaved = false; Hide();&#125; 这里还有另一个从StackOverflow找到的Dialog生成方法，链接已不可考…… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class DialogUtil&#123; public static ContentDialog ActiveDialog; static TaskCompletionSource&lt;bool&gt; DialogAwaiter = new TaskCompletionSource&lt;bool&gt;(); public static async void CreateContentDialog(ContentDialog Dialog, bool awaitPreviousDialog) &#123; await CreateDialog(Dialog, awaitPreviousDialog); &#125; public static async Task CreateContentDialogAsync(ContentDialog Dialog, bool awaitPreviousDialog) &#123; await CreateDialog(Dialog, awaitPreviousDialog); &#125; private static void ActiveDialog_Closed(ContentDialog sender, ContentDialogClosedEventArgs args) &#123; DialogAwaiter.SetResult(true); &#125; public static async void Info(string text) &#123; await DialogUtil.CreateContentDialogAsync(new ContentDialog &#123; Title = "Info", Content = new TextBlock &#123; Text = text, TextWrapping = TextWrapping.Wrap &#125;, PrimaryButtonText = "好的" &#125;, awaitPreviousDialog: true); &#125; static async Task CreateDialog(ContentDialog Dialog, bool awaitPreviousDialog) &#123; if (ActiveDialog != null) &#123; if (awaitPreviousDialog) &#123; await DialogAwaiter.Task; DialogAwaiter = new TaskCompletionSource&lt;bool&gt;(); &#125; else ActiveDialog.Hide(); &#125; ActiveDialog = Dialog; ActiveDialog.Closed += ActiveDialog_Closed; await ActiveDialog.ShowAsync(); ActiveDialog.Closed -= ActiveDialog_Closed; &#125;&#125;``### 文件读写UWP文件读写功能又被限制，一般是只能读写App本地文件夹，还可以请求诸如图片库、视频库等库文件夹，要是想要访问任意文件的话，就需要更改`Package.appxmanifest`了。因为本App需要序列化文件列表及其参数，恰好要用到本地文件读写。具体操作的话可以查看VS的代码提示或 [文档](https://docs.microsoft.com/en-us/windows/uwp/files/quickstart-reading-and-writing-files)。``` csprivate static StorageFolder localFolder = ApplicationData.Current.LocalFolder;//读文件StorageFile file = await localFolder.CreateFileAsync(jsonFile, CreationCollisionOption.OpenIfExists);string JSONContent = await FileIO.ReadTextAsync(file);//写文件string configJson = JsonConvert.SerializeObject(dj);StorageFile file = await localFolder.CreateFileAsync(jsonFile, CreationCollisionOption.OpenIfExists);await FileIO.WriteTextAsync(file, configJson); 服务进程的启动相关内容请参见 看FullTrustProcessLauncher的文档，有两个方法供启动进程，前者是启动的，后者是根据GroupId启动相应进程的，这里只用前者就够了。 123// public static IAsyncAction LaunchFullTrustProcessForCurrentAppAsync();// public static IAsyncAction LaunchFullTrustProcessForCurrentAppAsync(string parameterGroupId);FullTrustProcessLauncher.LaunchFullTrustProcessForCurrentAppAsync(); NurseryLauncher问题父进程退出后（子进程不退出）端口不释放NurseryLauncher.exe（绑定626端口）启动 puppet.exe（80端口）后，再手动关闭NurseryLauncher.exe， 从下图可以看出，根据端口查看进程，有pid存在，但是没有该进程。查子进程puppet.exe一切正常。这样导致的问题是：下次NurseryLauncher.exe因为端口占用不能正常启动 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>.Net</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>C#</tag>
        <tag>UWP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nursery 开发笔记]]></title>
    <url>%2F2020%2F09%2F28%2Fnursery-notes%2F</url>
    <content type="text"><![CDATA[Nursery是一个简单的进程托管Demo，用于启动console应用程序。 问题CheckBoxList这里一开始用的是ObservableCollection的方式，后感感觉太过于繁杂，改为直接向ListBox中添加CheckBox：ProcessListBox.Items.Add(checkBox);。 ListView的动态更新或许有用的资料 CheckBoxList(ObservableCollection)in WPF WPF ListView实时更新及INotifyPropertyChanged使用演示 WPF Listview绑定数据发生改变后前端没有更新 尝试这里想的是另起一个监控线程，对线程的实时信息进行更新。对infoList更新后，通过ProcessInformationListView.ItemsSource = infoList;使其生效，但是遇到了线程间对对象访问的问题： System.InvalidOperationException:“调用线程无法访问此对象，因为另一个线程拥有该对象。 123456ProcessInformationListView.Dispatcher.BeginInvoke(new Action(() =&gt;&#123; ProcessInformationListView.ItemsSource = infoList; ArgsButton.Content = "test"; logger.Info("size:" + infoList.Count);&#125;)); 改成这段代码之后，监控线程（monitor）能更改主线程的对象（button的内容发生更改可以证明），但是ListView的内容并不会更改。不仅如此，monitor执行后主线程不能向ListView中添加内容了，如果先添加了内容，monitor执行后内容不会改变。 最终解决方式 LIstView的数据源使用ObservableCollection：private ObservableCollection InfoList { get; set; } 实体类ProcessInformation继承INotifyPropertyChanged接口 123456789101112131415161718192021222324252627282930313233public class ProcessInformation : INotifyPropertyChanged &#123; private string _Process; private int _PID; private string _CPU; private string _Memory; public event PropertyChangedEventHandler PropertyChanged; public string Process &#123; get &#123; return _Process; &#125; set &#123; _Process = value; PropertyChanged?.Invoke(this, new PropertyChangedEventArgs("Process")); &#125; &#125; public int PID &#123; get &#123; return _PID; &#125; set &#123; _PID = value; PropertyChanged?.Invoke(this, new PropertyChangedEventArgs("PID")); &#125; &#125; public string CPU &#123; get &#123; return _CPU; &#125; set &#123; _CPU = value; PropertyChanged?.Invoke(this, new PropertyChangedEventArgs("CPU")); &#125; &#125; public string Memory &#123; get &#123; return _Memory; &#125; set &#123; _Memory = value; PropertyChanged?.Invoke(this, new PropertyChangedEventArgs("Memory")); &#125; &#125; &#125; 跨线程访问（这个就不用了，因为ObservableCollection实现了INotifyPropertyChanged接口，当InfoList发生改变时会自动更新ListView，不用手动更新ListView.ItemsSource，也就不会发生跨线程访问ListView了。ps: 好像是跨线程更改前台的数据才会出现这个问题） 不更新、不能添加GridView的原因也应该是没有实现INotifyPropertyChanged接口 1234ProcessInformationListView.Dispatcher.BeginInvoke(new Action(() =&gt;&#123; ProcessInformationListView.ItemsSource = InfoList;&#125;)); 不支持从调度程序线程以外的线程对其 SourceCollection 进行的更改123private ObservableCollection&lt;ProcessInformation&gt; infoList &#123; get; set; &#125;infoList = new ObservableCollection&lt;ProcessInformation&gt;();infoList.Remove(item); System.NotSupportedException:“该类型的 CollectionView 不支持从调度程序线程以外的线程对其 SourceCollection 进行的更改。” ObservableCollection类型的CollectionView不支持从调度程序线程以外的线程对其 SourceCollection 进行的更改。（我也不懂是哪个线程对该对象进行了访问，不是我的监控线程） 解决方式： 1234567891011121314151617ThreadPool.QueueUserWorkItem(delegate&#123; SynchronizationContext.SetSynchronizationContext(new DispatcherSynchronizationContext( System.Windows.Application.Current.Dispatcher)); SynchronizationContext.Current.Post(pl =&gt; &#123; for (int i = 0; i &lt; infoList.Count; i++) &#123; var item = infoList[i]; if (item.Process.Equals(fileName)) &#123; infoList.Remove(item); return; &#125; &#125; &#125;, null);&#125;); 功能与插件NotifyIcon程序托盘图标用的是HandyControl的控件。根据文档编辑图标、绑定事件即可。 12345678910&lt;hc:NotifyIcon x:Name="NotifyIcon" Text="ProcessNursery" Visibility="Visible" Icon="/assets/Nursery32x32.ico" Click="NotifyIcon_Click"&gt; &lt;hc:NotifyIcon.ContextContent&gt; &lt;StackPanel VerticalAlignment="Center"&gt; &lt;Button Command="hc:ControlCommands.PushMainWindow2Top" MinWidth="100" Content="OpenPanel"/&gt; &lt;Button Click="ExitApp" MinWidth="100" Style="&#123;StaticResource ButtonPrimary&#125;" Content="Exit"/&gt; &lt;/StackPanel&gt; &lt;/hc:NotifyIcon.ContextContent&gt;&lt;/hc:NotifyIcon&gt; 日志系统NLog的日志系统，主要是调试时候找问题的。 分为以下几种日志等级： Trace Debug Info Warn Error Fatal 配置NLog使用需要添加配置文件，可以添加到App.config，也可以新建NLog.config然后添加内容。我手动新建配置文件之后使用不了，使用NuGet命令添加成功。（工具->NuGet 包管理器->程序包管理器控制台，输入Install-Package NLog.Config [-Version 4.7.5]）。关于自定义日志，可以看这里 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;nlog xmlns="http://www.nlog-project.org/schemas/NLog.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.nlog-project.org/schemas/NLog.xsd NLog.xsd" autoReload="true" throwExceptions="false" internalLogLevel="Off" internalLogFile="c:\temp\nlog-internal.log"&gt; &lt;targets&gt; &lt;target name="console" xsi:type="ColoredConsole" layout="$&#123;date:format=yyyy/MM/dd HH\:mm\:ss&#125; $&#123;uppercase:$&#123;level&#125;&#125;&gt; $&#123;message&#125;"&gt; &lt;highlight-row condition="level == LogLevel.Debug" foregroundColor="Green" /&gt; &lt;highlight-row condition="level == LogLevel.Info" foregroundColor="Cyan" /&gt; &lt;highlight-row condition="level == LogLevel.Warn" foregroundColor="Yellow" /&gt; &lt;highlight-row condition="level == LogLevel.Error" foregroundColor="Red" /&gt; &lt;highlight-row condition="level == LogLevel.Fatal" foregroundColor="Red" backgroundColor="White" /&gt; &lt;/target&gt; &lt;target name="debugger" xsi:type="Debugger" layout="$&#123;date:format=HH\:mm\:ss&#125; | $&#123;level:padding=-5&#125; | $&#123;message&#125;" /&gt; &lt;/targets&gt; &lt;rules&gt; &lt;logger name="*" writeTo="console" /&gt; &lt;logger name="*" minlevel="Debug" writeTo="debugger" /&gt; &lt;/rules&gt;&lt;/nlog&gt; 使用1234private static Logger logger = LogManager.GetCurrentClassLogger();logger.Debug("Debug");logger.Info("Info");logger.Error("Error"); 进程的CPU与内存使用.Net的PerformanceCounter类型对进程的性能进行监控 12345Process process = pNersury[fileName].process;PerformanceCounter cpuCounter = new PerformanceCounter("Process", "% Processor Time", process.ProcessName);PerformanceCounter memCounter = new PerformanceCounter("Process", "Working Set", process.ProcessName);infoList[i].CPU = cpuCounter.NextValue().ToString() + CPUnit;infoList[i].Memory = ((long)memCounter.NextValue() &gt;&gt; 10).ToString() + MemoryUnit; 实时获取子进程的输出参考： 启动一个进程并实时获取状态信息 c# - 从Process获取实时输出 UseShellExecute必须为false，不然无法在代码中读标准。RedirectStandardOutput必须为true，这样我们才能在代码中访问标准流。EnableRaisingEvents必须为true，这样才会引发OutputDataReceived和Exited 解决方式是两条内容的结合： 1234567891011121314151617Process child = new Process();child.StartInfo.RedirectStandardOutput = true;child.StartInfo.RedirectStandardError = true;child.StartInfo.CreateNoWindow = true;child.StartInfo.UseShellExecute = false;child.EnableRaisingEvents = true; // 这样才会引发OutputDataReceivedchild.OutputDataReceived += new DataReceivedEventHandler((s, e) =&gt;&#123; Console.WriteLine(e.Data);&#125;);child.ErrorDataReceived += new DataReceivedEventHandler((s, e) =&gt;&#123; Console.WriteLine(e.Data);&#125;);child.Start();child.BeginOutputReadLine();child.BeginErrorReadLine(); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>.Net</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>C#</tag>
        <tag>WPF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 技巧]]></title>
    <url>%2F2020%2F02%2F28%2Fpython-notes%2F</url>
    <content type="text"><![CDATA[这里记录了 Python 中不熟悉或者古怪的操作。🧐 字符串二元运算测试非空字符串之间进行 and 运算，返回最后一个字符串，进行 or 运算返回首个字符串，但对 True 和 False 不适用🙅‍。 非空字符串之间12345&gt;&gt;&gt; 'str' and 'int''int'&gt;&gt;&gt; 'str' or 'int''str' 空与非空字符串12345678&gt;&gt;&gt; 'str' and ''''&gt;&gt;&gt; '' and 'str'''&gt;&gt;&gt; 'str' or '''str'&gt;&gt;&gt; '' or 'str''str' 字符串与布尔值1234567891011# True&gt;&gt;&gt; True and 'str''str'&gt;&gt;&gt; 'str' and TrueTrue# False&gt;&gt;&gt; False and 'str'False&gt;&gt;&gt; 'str' and FalseFalse 且运算列元素与行元素进行“且”运算，如：'str' and 'int' 123456| and | 'int' '' True False |---------------- ---------------------| 'str' | 'int' '' True False || '' | '' '' '' '' || True | 'int' '' True False || False | False False False False | 列元素与行元素行“且”运算，如：'int' and 'str' 123456| and | 'str' '' True False |--------------------------------------| 'int' | 'str' '' True False || '' | '' '' '' '' || True | 'str' '' True False || False | False False False False | 或运算列元素与行元素进行“或”运算，如：'str' or 'int' 123456| or | 'int' '' True False |--------------------------------------| 'str' | 'str' 'str' 'str' 'str' || '' | 'int' '' True False || True | True True True True || False | 'int' '' True False | 列元素与行元素行“且”运算，如：'int' or 'str' 123456| or | 'str' '' True False |--------------------------------------| 'int' | 'int' 'int' 'int' 'int' || '' | 'str' '' True False || True | True True True True || False | 'str' '' True False | 多元运算12 元组拆包拆包1 函数匿名函数匿名函数只能有一个表达式，不写return，表达式的结果就是返回值 12f = lambda x: x*xf() 闭包外层函数引用了内层函数的变量（参数也算变量），然后返回内层函数的情况，称之为闭包（Closure）。 123def outer(parms): def inner(): return parms 装饰器decorator 本质上是一个高阶函数，它接收一个函数作为参数，然后返回一个新函数。 123456789101112131415161718192021222324def Log(f): print("call ", f.__name__) return f# 装饰器"@Log"等价于 "func = Log(func)"@Logdef func(): print("Hello World!")func()# call func# Hello World!# 如果需要在装饰器中传入参数，可以用闭包def LOG(f): def flog(*args, **kwargs): print("call ", f.__name__) return f(*args) return flog@LOGdef func(): print("Hello World!") 面向对象类属性和实例属性如果更改某一实例的类属性，则只影响该实例，类和其他实例的类属性不受影响。此操作实际上是给该实例添加了一个实例属性并为其赋值，访问该实例“类属性”的时候，实际上访问的是其“实例属性”因为当实例属性和类属性重名时，实例属性优先级高，会屏蔽掉类属性的访问。 解释代码慕课网12345678910111213141516171819class Person(object): address = 'Earth' def __init__(self, name): self.name = namep1 = Person('Bob')p2 = Person('Alice')print 'Person.address = ' + Person.addressp1.address = 'China'print 'p1.address = ' + p1.addressprint 'Person.address = ' + Person.addressprint 'p2.address = ' + p2.address"""Output: Person.address = Earthp1.address = ChinaPerson.address = Earthp2.address = Earth""" isinstalce() & type()isinstalce()用来判断一个对象和一个已知类型是否相同，考虑继承关系，会认为子类是一种父类类型，而type()不考虑继承关系。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Latex自定义设置]]></title>
    <url>%2F2019%2F05%2F14%2Flatex-notes%2F</url>
    <content type="text"><![CDATA[$\LaTex$论文写作笔记 Latex样式页面尺寸12\usepackage&#123;geometry&#125;\geometry&#123;a4paper, left=2.4cm, top=2.4cm, right=2.4cm, bottom=2.4cm&#125; % 页边距 页眉页脚L、C、R分别表示左、中、右；E、O表示奇偶页，页眉页脚的设置中可以使用它们的组合，多选项的情况用中括号分开。现在有几个问题： 页眉需要的样式是：奇数页居中显示章节号，偶数页显示“东北林业大学本科毕业论文”，但是通过[CE]、[CO]设置就不行，而且只设置\fancyhead[CE]{\song\xiaowu{东北林业大学本科毕业论文}}也会失败，什么都不显示。 双线页眉的长度一开始是\headwidth，右侧没有达到文档宽度的位置。改为\columnwidth或\textwidth之后，长度虽然改变了，但是文字的位置没有随之向右移动（没有居中） 问题1中的章节号不知道怎么获取……123456789101112131415161718\usepackage&#123;fancyhdr&#125;%------- 页眉页脚样式 -------%\pagestyle&#123;fancy&#125;\fancyhf&#123;&#125; % 清空设置\fancyhead[C]&#123;\song\xiaowu&#123;东北林业大学本科毕业论文&#125;&#125;% \fancyhead[CO]&#123;\thechapter&#125;\fancyfoot[C]&#123;\xiaowu&#123;-\thepage-&#125;&#125;\renewcommand&#123;\headrulewidth&#125;&#123;0.4pt&#125;%------- 双线页眉的设置 -------%\makeatletter %双线页眉\def\headrule&#123;&#123;\if@fancyplain\let\headrulewidth\plainheadrulewidth\fi%\hrule\@height 1.0pt \@width\columnwidth\vskip1pt%上面线为1pt粗\hrule\@height 0.5pt\@width\columnwidth %下面0.5pt粗\vskip-2\headrulewidth\vskip-1pt&#125; %两条线的距离1pt \vspace&#123;6mm&#125;&#125; %双线与下面正文之间的垂直间距\makeatother Latex功能图片标题的样式把图片标题默认的“图1:示例”更改为“图2-1 示例”。其中： thesection{} 表示章节号 两个命令分别设置表格和插图的格式 命令中的“-”可以用“.”等符号代替，以适应不同的要求123\renewcommand &#123;\thetable&#125; &#123;\thesection&#123;&#125;-\arabic&#123;table&#125;&#125; \renewcommand &#123;\thefigure&#125; &#123;\thesection&#123;&#125;-\arabic&#123;figure&#125;&#125;\captionsetup&#123;labelformat=default,labelsep=space&#125; %去除冒号 公式编号样式123456\renewcommand\theequation&#123;\arabic&#123;section&#125;-\arabic&#123;equation&#125;&#125; % 公式引用输出样式\begin&#123;equation&#125; (\ref&#123;Formula.Second.1&#125;) \Leftrightarrow S(i,j)=(K*I)(i,j)=\sum_m \sum_n I(i-m,j-n)K(m,n)\label&#123;Formula.Second.3&#125;\end&#123;equation&#125;(\ref&#123;Formula.Second.3&#125;)式也被称为I和K的互相关 并排图片1234567891011121314\begin&#123;figure&#125;[htbp] \centering %图片全局居中 \subfigure[原图]&#123; \includegraphics[width=0.2\textwidth]&#123;resource/2-原图.jpg&#125; &#125; \subfigure[互相关]&#123; \includegraphics[width=0.2\textwidth]&#123;resource/2-互相关.jpg&#125; &#125; \subfigure[卷积]&#123; \includegraphics[width=0.2\textwidth]&#123;resource/2-卷积.jpg&#125; &#125; \caption&#123;卷积核的翻转对特征提取的影响&#125; \label&#123;Figure.Second.1&#125; \end&#123;figure&#125; 并排图片组1234567891011121314151617181920212223242526\begin&#123;figure&#125;[H] \centering %图片全局居中 \subfigure[叶枯病]&#123; \begin&#123;minipage&#125;[t]&#123;.2\textwidth&#125; \includegraphics[width=\textwidth]&#123;resource/third/blight(1).jpg&#125; \ \includegraphics[width=\textwidth]&#123;resource/third/blight(2).jpg&#125; \ \includegraphics[width=\textwidth]&#123;resource/third/blight(3).jpg&#125; \end&#123;minipage&#125; &#125; \subfigure[白粉病]&#123; \begin&#123;minipage&#125;[t]&#123;.2\textwidth&#125; \includegraphics[width=\textwidth]&#123;resource/third/powdery(1).jpg&#125; \ \includegraphics[width=\textwidth]&#123;resource/third/powdery(2).jpg&#125; \ \includegraphics[width=\textwidth]&#123;resource/third/powdery(3).jpg&#125; \end&#123;minipage&#125; &#125; \subfigure[锈病]&#123; \begin&#123;minipage&#125;[t]&#123;.2\textwidth&#125; \includegraphics[width=\textwidth]&#123;resource/third/rust(1).jpg&#125; \ \includegraphics[width=\textwidth]&#123;resource/third/rust(2).jpg&#125; \ \includegraphics[width=\textwidth]&#123;resource/third/rust(3).jpg&#125; \end&#123;minipage&#125; &#125; \caption&#123;数据样本&#125; \label&#123;Figure.Third.6&#125; \end&#123;figure&#125; 插入代码块12345678910111213141516171819\usepackage&#123;listings&#125; % 代码块\lstset&#123; % 代码块设置 basicstyle=\xiaowu\fontspec&#123;Consolas&#125;, columns=fixed, % numbers=left, % 在左侧显示行号 % numberstyle=\tiny\color&#123;gray&#125;, % 设定行号格式 frame=none, % 不显示背景边框 backgroundcolor=\color[RGB]&#123;245,245,244&#125;, % 设定背景颜色 keywordstyle=&#123; % 设定关键字颜色 \color[RGB]&#123;40,40,255&#125; \fontspec&#123;Consolas&#125; &#125;, numberstyle=\footnotesize\color&#123;darkgray&#125;, commentstyle=\it\color[RGB]&#123;0,96,96&#125;, % 设置代码注释的格式 stringstyle=\rmfamily\slshape\color[RGB]&#123;128,0,0&#125;, % 设置字符串格式 showstringspaces=false, % 不显示字符串中的空格 language=python, % 设置语言&#125; 参考文献（bibtex）将bibtex格式的文本保存在论文同目录的references.bib文件中，并在论文合适的地方插入该语句： 12\bibliographystyle&#123;unsrt&#125; % 文献标准选项\bibliography&#123;references&#125; references.bib12345678910@article{hubel1962receptive, title={Receptive fields, binocular interaction and functional architecture in the cat's visual cortex}, author={Hubel, David H and Wiesel, Torsten N}, journal={The Journal of physiology}, volume={160}, number={1}, pages={106--154}, year={1962}, publisher={Wiley Online Library}} 在论文中插入\cite{hubel1962receptive}以引用参考文献 LaTeX 参考文献标准选项及其样式共有以下8种： plain，按字母的顺序排列，比较次序为作者、年度和标题 unsrt，样式同plain，只是按照引用的先后排序 alpha，用作者名首字母+年份后两位作标号，以字母顺序排序 abbrv，类似plain，将月份全拼改为缩写，更显紧凑 ieeetr，国际电气电子工程师协会期刊样式 acm，美国计算机学会期刊样式 siam，美国工业和应用数学学会期刊样式 apalike，美国心理学学会期刊样式 参考文献编号上标将\cite命令替换为\upcite命令。 1\newcommand&#123;\upcite&#125;[1]&#123;\textsuperscript&#123;\textsuperscript&#123;\cite&#123;#1&#125;&#125;&#125;&#125; 插入pdf1234\usepackage&#123;pdfpages&#125;\begin&#123;document&#125;\includepdf[⟨key=val⟩]&#123;⟨filename⟩&#125;\end&#123;document&#125; \includepdf{file.pdf} 默认插入第一页 \includepdf[pages={1,2}]{file.pdf} 插入第1、2页 \includepdf[pages={3-5}]{file.pdf} 插入第3、4、5页 \includepdf[pages={3,{},8-11,15}]{file.pdf} 依次插入第3页、空白页、第8、9、10、11、15页 \includepdf[pages=-]{file.pdf} 全部插入 更多参数详见pdfpages文档：texdoc pdfpages 插入自定义宽度字符为了应付查重而想出的奇技淫巧，经测试没什么B用 \newcommand{\zs}{\hspace{0pt}} 零宽空格 \newcommand{\zs}{\hspace{-1pt}{\color{white}.}\hspace{-1.8pt}} 插入白色的“.”，并减小其宽度使其看起来并没有插入任何字符下图对比可看出“.”的存在 Latex问题引入图片时报图片文件找不到的错误这个问题在写作前期没有出现，后来不知道做了什么改动才报这个错误的。把图片的文件名改成英文解决了。 图表编号清零没有专门设置的情况下，新的一章中插图的编号不会清零，在开头插入以下代码即可： 12\setcounter&#123;table&#125;&#123;0&#125;\setcounter&#123;figure&#125;&#123;0&#125; 中文加粗失败你可能需要这个：AutoFakeBold，在\documentclass[12pt, UTF8, AutoFakeBold]{ctexart}中加入。解决方案来自这里：xelatex编译加粗楷体为什么会失败？ 插入图片位置latex为了排版的美观，可能图片的位置和源码中的位置不相对应，如果要强制插图在某一位置，需要\usepackage{float}， 在图片中加入[H]选项替代[htbp]以强制图片在该位置。 图片尺寸有的情况下不指出图片的尺寸，直接插入图片会报错，在选项中使用natwidth和natheight可以解决问题。\includegraphics[width=\textwidth, natwidth=1612, natheight=482]{resource/second/LeNet-5.png} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>LaTex</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>LaTex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Electron-Vue遇到的诸多问题]]></title>
    <url>%2F2019%2F03%2F26%2Felectron-issues%2F</url>
    <content type="text"><![CDATA[由于个人水平原因遇到的解决不了或已经解决的问题。 环境构建Webpack ReferenceError: process is not defined1234567891011121314151617ERROR in Template execution failed: ReferenceError: process is not defined ERROR in ReferenceError: process is not defined - index.ejs:11 eval [.]/[html-webpack-plugin]/lib/loader.js!./src/index.ejs:11:2 - index.ejs:16 module.exports [.]/[html-webpack-plugin]/lib/loader.js!./src/index.ejs:16:3 - index.js:284 [Buper]/[html-webpack-plugin]/index.js:284:18 - runMicrotasks - task_queues.js:97 processTicksAndRejections internal/process/task_queues.js:97:5 saved webpack.renderer.config.js12345678910111213141516new HtmlWebpackPlugin({ filename: 'index.html', template: path.resolve(__dirname, '../src/index.ejs'), minify: { collapseWhitespace: true, removeAttributeQuotes: true, removeComments: true }, // ↓ 2020-03-10 https://github.com/SimulatedGREG/electron-vue/issues/871#issuecomment-529809406 isBrowser: false, isDevelopment: process.env.NODE_ENV !== 'production', // ↑ 2020-03-10 https://github.com/SimulatedGREG/electron-vue/issues/871#issuecomment-529809406 nodeModules: process.env.NODE_ENV !== 'production' ? path.resolve(__dirname, '../node_modules') : false}), index.ejs123456&lt% if (!htmlWebpackPlugin.options.isBrowser && !htmlWebpackPlugin.options.isDevelopment) { %&gt script window.__static = require('path').join(__dirname, '/static').replace(/\\/g, '\\\\') /script&lt% } %&gt Electron & VueipcRenderer.send()函数不能工作-2019/03/26Console里的错误描述： [Vue warn]: Error in v-on handler: “TypeError: electron__WEBPACK_IMPORTED_MODULE_3___default.a.send is not a function”found in—> at src/renderer/components/Gallery/Gallery.vue at src/renderer/components/MainPage.vue at src/renderer/App.vue TypeError: electron__WEBPACK_IMPORTED_MODULE_3___default.a.send is not a function at VueComponent.drop (Gallery.vue?f747:125) at drop (Gallery.vue?f24d:127) at invokeWithErrorHandling (vue.esm.js?a026:1863) at HTMLDivElement.invoker (vue.esm.js?a026:2188) at HTMLDivElement.original._wrapper (vue.esm.js?a026:7542) 该问题可能的原因是：在引入ipcRenderer的时候写成了import ipcRenderer from 'electron'，改成const {ipcRenderer} = require('electron')不再显示错误。 ipcRenderer和ipcMainipcRenderer和ipcMain这两个类之间传递的数据是object格式，即使你在ipcRenderer里向ipcMain发送的是数组。只这么单向地说是因为在文件对话框里选择的文件经sender发送到ipcRenderer后，其object格式使用forEach不会报错。具体原因待研究。 ipcRenderer.on重复执行（dialog）问题描述：点击按钮打开对话框，选择文件并输出在屏幕上。第一次打开对话框选择一个图片，会有一个图片添加到视图上；再打开对话框选择一个或多个图片，会进来双倍相同的图片；接着再打开会有三倍，四倍……这是个从一开始就令我脑壳痛的问题，来回测试代码就是找不到问题在哪，但是知道是在ipcRenderer.on()中反复执行的，之前存储数据的格式简单：数组可以去重，简单对象可以用图片的src做键，直接去掉重复的图片链接。而把数据存储到Vuex的store中之后，加上编辑页面的需要，数据结构变得复杂，变成了对象列表，这就不得不解决这个问题。后来还是在Stack Overflow中找到了解决办法：把ipcRenderer.on()用ipcRenderer.once()替代，这是因为每一次点击按钮打开dialog都会设置一个监听器，多次打开就需要手动删除之前的监听器，这样子很麻烦，用ipcRenderer.once()就会在程序块执行结束后自行删除监听器。 dialog选择文件夹会返回undefined这是一个原因不明的问题，还没去StackOverflow上找找。现在的做法是直接过滤掉undefined的数据，目前没有很大的问题。 Vue & VuexVue数据更新，视图不更新-2019/03/24点击文件对话框可以添加图片，但是拖入就添加不了，vue的数据对象也更新了，可能是更新数据的方法有问题。参考Vue中数组和对象更改后视图不刷新的问题尝试了N种方法，仍然tmd解决不了，考虑添加初始化图片。 添加初始化图片仍然不能解决问题，情况是dom中有添加的卡片元素，就是在页面上没有显示。经过多次查找，在.card-columns的外层div上有一个v-show='showTip'(showTip=false)，而且在设计页面的时候多包上了一层div（具体记不太清楚了，应该是给功能扩展留出的空间）。最后解决的方式是：去掉了多余的div和v-show=false，重新写了一下gallery相关的样式，得以解决。 全局变量、函数-2019/03/26谷歌了很多种注册全局变量、函数的方法，在我这里都行不通，可能是我个人水平的原因。最后解决的方案是，将三代组件合并成父子两代组件，在父组件里声明大部分变量，然后通过props和this.$emit()方法在父子组件之间通信并同步变量解决了问题。 在使用this.drag_tip_seen_flag = true;this.$emit('get_drag_tip_seen_flag', drag_tip_seen_flag)向父组件传递更改过的dragTipSeenFlag变量的情况下，当点击&times;关闭选项卡的时候，Console会出现Vue的警告: [Vue warn]: Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop’s value. Prop being mutated: “drag_tip_seen_flag”[Vue warn]: Error in v-on handler: “ReferenceError: drag_tip_seen_flag is not defined”found in…… 意思是由于更改了变量而警告改变量可能会被覆盖，需要注意。在把该两行代码换成this.$emit('get_drag_tip_seen_flag', true)之后，警告消失。这里的解决方式只是个例，如果父子组件之间互相传递的变量比较多而引发该问题时，就需要考虑换一种方法了。（我是tmd再也不想接触vue的全局变量和全局函数了） Vuex state数据返回错误在将数据移至Vuex后，发现从state中获取的bool数据不符合预期，总是返回错误的数据。只有在一开始初始化的时候才正确，更不用说更新这个state了。 [vuex] do not mutate vuex store state outside mutation handlers. 2019/04/07意思是说不要在mutation之外更改state中变量的值，例如再actions中对state中某一变量赋值就会出现此错误。 界面布局card-columns布局-2019/03/23图片少于4张的时候会显示两列（同理，少于两张会显示1列），这是因为页面设计的排版是面向列布局的，当图片大于4张的时候自动会占满3列。 卡片阴影移位-2019/03/24Bootstrap中.card-columns>card加CSS阴影后，card[1,2]和card[1,3]上方阴影被截取到前一列最下方。猜测时因为.card-columns的面向列排版，导致阴影被错位了。解决方法：在.card的CSS里加一个margin: 8px;，给卡片上方阴影留出空间即可。 Node.js奇怪的字符202A在读取图片的测试过程中，由于路径字符串的问题，导致读取文件时路径被当成相对路径处理报错。当我把该字符串放到控制台处理时，用其作为路径执行会报“文件不存在”的错误。然后通过string.charCodeAt(0)发现字符串的第一位出现了一个不常见的字符8234，16进制为202AH，谷歌了一下看着好像是一个控制字符，可能是我在文件属性的“安全选项卡”复制路径的时候多复制了一个字符，让重新用正确的路径字符串读取文件的时候，错误消失。 当把该字符复制到js代码里时，编辑器里是看不到的，但是会报代码语法错误。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Node.js</category>
        <category>Electron</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Electron-Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Electron-Vue开发笔记]]></title>
    <url>%2F2019%2F03%2F23%2Felectron-note%2F</url>
    <content type="text"><![CDATA[对于Electron的了解，还是开始于Motrix，一个颜值极高的多功能下载工具。在GitHub项目页面看到了“Electron”一词，从此开始了废寝忘食的学习过程…… 从electron到electron-vue，不仅重拾了之前自学的Html、CSS、js，还扩展到了Node.js，还有Vue、Bootstrap等前端框架。虽然现在并不知道他们到底是用来干嘛的（Vue，我说谁呢自己心里去除），但也有个初步的了解了。 环境 欲练此功，必先自宫。 刚准备拿起书看计算机组成原理，就在知乎上看到有人推荐Motrix这个东西，惊讶于颜值，了解项目的技术栈后，又感叹于技术。心里默默想着，这书怕是，看不成了。 抄代码很多代码及代码风格都模仿自Motrix（羞羞😶） 样式与排版感觉好多种样式不对的情况都是没有刷新（瞎写定位） 打开对话框打开对话框的尝试倒没有踩多少坑，看electron文档就可以handle。 注意选择文件和文件夹-2019/03/26在对话框文档中有这么一句： 在 Windows 和 Linux 上, 打开对话框不能同时是文件选择器和目录选择器,因此如果在这些平台上将 properties 设置为[“openFile”、”openDirectory”],则将显示为目录选择器。 若对选择文件和文件夹都有需要，则应将它们分开处理。 文件夹-2019/03/26在读取文件夹下的文件目录时，可以用forEach循环，因为forEach是同步的，即使没有Sync（详见该博客）。在该循环内也建议使用同步函数，否则可能会遇到数据还没来得及传出来就返回的问题。当然，返回为空（或不全）。 小结经过三天没日没夜地折腾，终于看到了一丝曙光。在bootstrap的加持下排版样式有了雏形，有了Vue的高级功能（没见过的都是高级），可以任意添加单个或多个图片了。 预览-2019/03/23现在的界面就是酱紫： 原生卡片（bootstrap中.card-columns的样式，加了自制页眉） 自制卡片 两种样式看起来只差一个图片的margin，看起来大小不太一样。但是设计的时候走了很多弯路。自制卡片没有使用.card-columns的时候图片的定位有问题： 宽>高的时候图片不能居中 高>宽的时候图片突破容器高度，向下伸出一大截。使用.card-group和.card-decks的时候一张图片占了整个页面，问题太多了，而且自己写的CSS也一直在变，没有太大的可比性。现在能做成这样子已经巨jb开心了，感觉自己啥都tm会…… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Node.js</category>
        <category>Electron</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>前端</tag>
        <tag>Electron-Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loline —— 加载本地json]]></title>
    <url>%2F2019%2F03%2F10%2Fmany-ways-to-loline%2F</url>
    <content type="text"><![CDATA[使用数据的几种方式RESTful API这种方式在上一篇文章中已经使用过。 在使用Ajax跨域请求json的方式下，遇到了两点麻烦： 阿里云服务器上运行的python脚本有不知名的问题。 GitHub Pages的博客上需要使用HTTPS来跨域请求，这就需要一个SSl证书，但是自己的证书不会被浏览器信任，而去阿里云申请证书（有免费的）需要注册域名，太麻烦了，所以就改变一下请求json的方式，改用本地加载数据的方式。 加载本地json 注意"/json/champions.json"不能写成"json/champions.json"的形式，不然会在post页面显示404错误。http://localhost:4000/2019/03/08/loline/json/champions.json 404 (Not Found) next\layout\_scripts\commons.swig12345678910 $.get("/json/champions.json", function (data) { var ranint = function(min, max) { return Math.round(Math.random() * (max - min)) + min; }(1, data.length); champion = data[ranint-1]; $('#loline-content').css('display', '').text(champion.words); $('#loline-from').css('display', '').text('——' + champion.title_zh+' '+champion.name_zh); }); 下边是相应的属性设置，但实际上和之前一言设置都差不多。 点击查看 next\layout\_macro\sidebar.swig12345678910 LOLine 直链访问可以以直链请求json的方式获取数据，数据源可以为博客所在的仓库。 这种方式返回的data数据类型为string，所以代码也有相应的更改。 next\layout\_scripts\commons.swig12345678910$.get("https://raw.githubusercontent.com/.../champions.json", function (data) { console.log('url: '+''); champions = JSON.parse(data); var ranint = function(min, max) { return Math.round(Math.random() * (max - min)) + min; }(1, data.length); champion = champions[ranint-1]; $('#loline-content').css('display', '').text(champion.words); $('#loline-from').css('display', '').text('——' + champion.title_zh+' '+champion.name_zh); }); CSS——数据展示模仿block-quote标签的样式，在侧边栏中加入block-loline，如此一来又出现了新问题：svg大小和颜色控制不好，便换回了原来的样子。 blockquote-loline样式查看代码： next\source\css\_common\components\tags\blockquote-center.styl1234567891011121314151617181920212223242526272829303132.blockquote-loline { position: relative; margin: 40px 0; padding: 0; border-left: none; text-align: center; &::before, &::after { position: absolute; content: ' '; display: block; width: 100%; height: 24px; opacity: 0.2; background-repeat: no-repeat; background-position: 0 -6px; background-size: 22px 22px; } &::before { top: -20px; background-image: url($sidebar-quote-left); border-top: 1px solid $grey-light; } &::after { bottom: -20px; background-image: url($sidebar-quote-right); border-bottom: 1px solid $grey-light; background-position: 100% 8px; } p, div { text-align: center; }} 设置base变量自定义了两个SVG，在SVG: path标签中可以加入fill="#B2B7F2"定义SVG的颜色。 在next\source\css\_common\components\tags\blockquote-center.styl中发现可用自定义变量，然后在下方文件中更改了以下原来的svg并新建了两个变量。 next\source\css\_variables\base.styl123// blockquote-loline icon 只是更改了一下颜色$sidebar-quote-left = '../images/sidebar-quote-l.svg'$sidebar-quote-right = '../images/sidebar-quote-r.svg' document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <tags>
        <tag>Loline</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loline——一个flask RESTful API]]></title>
    <url>%2F2019%2F03%2F08%2Floline%2F</url>
    <content type="text"><![CDATA[Loline受于一言的启发，利用今天一下午的时间利用flask建立了一个轻量级的RESTful API——Loline。其内容大抵是英雄联盟143位英雄的中英文绰号、名字和pick台词。 下文所列出的部分网站可能需要科学上网才能访问 一开始要收集到所有英雄的全部台词的，发现收集这些东西真的很难。 中文名称及绰号这个是在鹅厂联盟官网资料库收集的，因为用了不懂的技术，网页源代码里边没有要找的数据，自然也不能用简单的爬虫来做这些事。还是浏览器开发者工具帮了忙：在Elements一栏可以复制想要的数据，然后保存到本地文件，就可以用Beautiful Soup来提取数据了。这里提取到的是中英文名称及中文绰号，然后根据英文名称去下一步爬取英文绰号。 英文绰号一开始去了拳头的开发网站，发现根本没有提供这种接口。后来发现在GamePedia的英雄详情页有需要的东西，但也仅仅是lol.qq.com的英文版（能用爬虫解决）。写好爬虫脚本，来回更改执行好几次才把英文绰号保存下来。 在GemaPedia-英雄联盟的主页仔细看了一下，也没找到英雄详细信息的入口，得在搜索栏搜索英雄的名字才能找到，例如：Teemo。 Pick台词然后又是pick台词的收集工作，这是最令人头疼的地方。在百度云搜素引擎上找到了大多数英雄的Word版英雄台词，但因为建立日期比较早，有很多台词已经更改了，再加上处理量比较大、需求量不高，就暂时搁置了那个Word。但总得有点内容吧，就选定了Pick英雄的台词，大都是百度谷歌搜集而来。因为英雄改版重做等原因，有些已经不适用了，然后自己启动游戏训练模式，选好英雄听语音，然后立马关掉……不知道百度、谷歌、开关游戏多少次，才勉强把143位英雄的台词收集完。因为有的英雄台词不太熟悉，可能有的已经过时而没有更改，这就等到发现再说吧。 Api的使用 使用方式经多次尝试，已经更新为新的方式。 使用方法是同一言一样 ，你同样可以参照原文作者的方式，但只需要根据下方代码把themes/next/layout/_macro/sidebar.swig中的id和Hitokoto的小标题改一下即可。 themes/next/layout/_scripts/commons.swig1234567 $.get('http://149.129.113.178:5000/', function (data) { console.log('----------------------------------------') console.log(data) $('#loline-content').css('display', '').text(data.words); $('#loline-from').css('display', '').text('——' + data.title_zh+' '+data.name_zh); }); 代码收集数据的时候也写了不少的代码，但保存下来数据之后其中大多数已经没有用了，所以这里只贴出来了Flask的代码。需要请邮件联系获取 😄 12345678910111213141516171819202122232425262728293031323334#! py -3# -*- coding: utf-8 -*-import jsonimport randomfrom util import load_championsfrom flask import Flask, jsonify, abort, make_response, request# http://www.pythondoc.com/flask-restful/first.htmlapp = Flask(__name__)app.config['JSON_AS_ASCII'] = Falsechampions = load_champions("data/champions.json")@app.route('/', methods=['GET'])def index(): id_ = random.randint(1, len(champions)) print(id_) champion = list(filter(lambda t: t['id'] == id_, champions)) return jsonify(champion[0])def after_requests(response): response.headers['Access-Control-Allow-Origin'] = '*' response.headers['Access-Control-Allow-Methods'] = 'GET' response.headers['Access-Control-Allow-Headers'] = 'Content-Type,Authorization' return response@app.errorhandler(404)def not_found(error): return make_response(jsonify({'error': 'Not Found'}), 404)if __name__ == '__main__': app.after_request(after_requests) app.run(debug=True) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Python</category>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Loline</tag>
        <tag>Flask</tag>
        <tag>json</tag>
        <tag>英雄联盟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages——Hexo配置笔记]]></title>
    <url>%2F2019%2F03%2F05%2Fstart-hexo%2F</url>
    <content type="text"><![CDATA[Hello Hexo! 填坑Markdown中不能使用变量Ruby-Jekyll环境下，是可以直接在markdown中插入yaml中定义的变量的，所以就可以把OSS(COS)存储的图片链接放到yaml里，方便管理。从Jekyll转到Hexo发现在markdown中使用变量是行不通的，但是知道了半点解决办法——注册插件：GitHub和知乎的解决方案。在此方案下我做了一些不完全的测试： 在source/_data目录下新建文件夹并有序存放yaml文件，在hexo generate过程中是找不到yaml文件的。 把yaml放在根目录下，能找到文件，但是找不到变量的键，1中也会有此种情况。 直接把数据放在站点配置文件中，可用找到变量并引用其值，但是只能硬编码，不能动态地找到变量，因为js中的变量类型是字符串 themes/next/scripts/include-variable.js12345678910hexo.extend.tag.register('variable', function(args) { // 这里 传入的变量 args[0] 类型是字符串，所以不能和 js 语句相连接，如：hexo.config.data.args[0] // `hexo g`过程中打印下列信息，也就是执行该文件 console.log("------------------variable---------------------"); console.log(args[0]) console.log(hexo.config.url) console.log(hexo.config.data.iOS) // return `img src="` + args[0] + `" /`; return ``+hexo.config.data.iOS; }); 关于代码块附加说明的样式在代码高亮主题night bright 下，使用{% codeblock %} {% endcodeblock %}添加说明后，页面显示字体颜色和背景相近，不容易分辨，可以更改css样式来解决这一问题： public/css/main.css12345678if $highlight_theme == "night bright" $highlight-background = #000000 $highlight-current-line = #2a2a2a $highlight-selection = #424242 $highlight-foreground = #555 /* #eaeaea */ $highlight-comment = #969896 $highlight-red = #d54e53 // …… 配置与美化图片并排Hexo默认情况下是不能让图片并排显示的，这里需要更改一下设置，将下方代码块的两行注释掉即可。Markdown中的语法{% gp 1-n %} {% endgp %}，n代表需要并排的图片个数。 不可在行内使用单反引号引用标签插件，否则会被hexo理解为插入标签。 next/source/css/_common/components/tags/group-pictures.styl123456.page-post-detail .post-body .group-picture-column { // float: none; margin-top: 10px; // width: auto !important; img { margin: 0 auto; }} 当图片设置为并排显示以后，不能使用”fancybox”的预览功能，要在另一个文件中注释掉一句代码： themes/next/source/js/src/utils.js12345wrapImageWithFancyBox: function() { $('.content img') .not(':hidden') // .not('.group-picture img, .post-gallery img') .each(function() { 一言来自这里：ouuan 在代码所示文件中找到这一字段：，然后在下边粘贴。 themes/next/layout/_macro/sidebar.swig123456789101112131415 “ ” Hitokoto themes/next/layout/_scripts/commons.swig123456 $.get('https://v1.hitokoto.cn/?c=a', function (data) { $('#hitokoto-content').css('display', '').text(data.hitokoto); $('#hitokoto-from').css('display', '').text('——' + data.from); }); themes/next/source/css/_custom/custom.styl123.sidebar { background: rgba(0, 0, 0, 0);} 折叠块功能详细内容请见该链接 所涉及到的文件： themes\next\scripts\tags.js themes\next\scripts\fold.js themes\next\source\js\src\post-details.js themes\next\source\css_custom\custom.styl 网页背景在这里学到的背景图设置，看到其博客效果后向朋友学习了如何去掉文章背景。 设置网页背景及文章透明度 themes/next/source/css/_custom/custom.styl123456789body { background-image:url(/images/background/20180830_040329207_iOS.jpg); background-repeat: no-repeat; // background-attachment:fixed; // 背景图不滚动 background-size: cover;}.main-inner { opacity: 0.8; // 文章透明度} 文章背景去除背景只需要把该元素的background属性注释掉即可。 使用深色背景会造成博客阅读困难 文章及文章预览 themes/next/source/css/_schemes/Pisces/_layout.styl1234567891011.content-wrap { float: right; box-sizing: border-box; padding: $content-desktop-padding; width: $content-wrap; // background: white; min-height: 700px; box-shadow: $box-shadow-inner; border-radius: $border-radius-inner; // …… } 阅读全文按钮 themes/next/source/css/_common/components/buttons.styl1234567891011121314.btn { display: inline-block; padding: 0 20px; font-size: $btn-default-font-size; color: $btn-default-color; // background: $btn-default-bg; border: $btn-default-border-width solid $btn-default-border-color; text-decoration: none; border-radius: $btn-default-radius; transition-property: background-color; the-transition(); line-height: 2; // ……} jemoji给Hexo添加对表情的支持，使用的是Github Emojis API 安装$ npm install hexo-filter-github-emojis --save 选项在Hexo配置文件_config.yml中添加默认设置： 123456githubEmojis: enable: true className: github-emoji inject: true styles: customEmojis: 如果对::添加表情的方式不感冒，可以尝试使用{% github_emoji sparkles %}方式添加表情🎉 在front-matter中添加no-emoji: true可以禁用::的渲染，但{% github_emoji sparkles %}不会被禁用✨ 标签插件bootstrap note使用方式{% note class_name %} Content (md partial supported) {% endnote %} default primary success info warning danger bootstrap note2里边加了分割线-------的话，匿名分割线上方的一行会变成同级标题 Gist{% gist gist_id file_name %} 点击查看gist 网络原因打不开gist swig标签{% raw %} content {% endraw %} 接下来浮动插入图片，像这个无法访问404只能以localhost:4000/404.html的方式访问 本页侧边栏滑到最上方，然后向右看👉 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPS使用指南]]></title>
    <url>%2F2019%2F03%2F02%2Fhow-to-start-a-vps%2F</url>
    <content type="text"><![CDATA[默念二十四字社会主义核心价值观 安装ShadowsocksR使用root用户登录，运行以下命令： 123456789101112# 安装ShadowsocksRwget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.shchmod +x shadowsocksR.sh./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log# 卸载ShadowsocksR./shadowsocksR.sh uninstall# 安装 BBRwget --no-check-certificate https://raw.githubusercontent.com/moeext/how-to-start-a-new-VPS/master/tcp.shchmod +x tcp.sh./tcp.sh 多用户配置示例12345678910111213141516171819202122&#123; "server":"0.0.0.0", "server_ipv6":"[::]", "local_address":"127.0.0.1", "local_port":1080, "port_password":&#123; "10657":"***", "10658":"***", "10659":"***", "10660":"***" &#125;, "timeout":120, "method":"aes-256-cfb", "protocol":"origin", "protocol_param":"", "obfs":"plain", "obfs_param":"", "redirect":"", "dns_ipv6":false, "fast_open":false, "workers":1&#125; 更改Python软连接查看已安装python版本 ls /usr/bin 12rm /usr/bin/pythonln -s /usr/bin/python3.5 /usr/bin/python 定时任务 crontab1234crontab -e#30 22 * * * python ~/email/pymail.py &gt;&gt; ~/email/pymail.log# 修改默认编辑器select-editor document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Software</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ssr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在LaTex中使用自定义字体]]></title>
    <url>%2F2019%2F02%2F22%2F2019-2-22-customize-font-in-latex%2F</url>
    <content type="text"><![CDATA[挖坑 刚接触LaTex，不太了解编译运行方式，网上搜了好多种方法都一直报错。这个例子刚测试的时候还编译不了，据猜测原因应该是编译缓存未清理或导入宏包的问题。 定义代码段字体下边是一种自定义字体的方法，来自LaTeX技巧006：使用不同的英文字体 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081\documentclass[UTF8]&#123;article&#125;\usepackage&#123;fontspec&#125;\setmainfont&#123;Times New Roman&#125;%fontspec下这个命令设置全局默认字体\begin&#123;document&#125;Hello World!\\%这也是一种调用方式，无须fontspec宏包\font\rm=&quot;Calibri&quot; at 14pt \rm This is Calibri\\\font\rm=&quot;Candara&quot; at 14pt \rm This is Candara\\\font\rm=&quot;Mistral&quot; at 14pt \rm This is Mistral\\\font\rm=&quot;Bahnschrift&quot; at 14pt \rm This is Bahnschrift\\\font\rm=&quot;Pristina&quot; at 14pt \rm This is Pristina\\\font\rm=&quot;Microsoft Uighur&quot; at 14pt \rm This is Microsoft Uighur\\\font\rm=&quot;Bradley Hand ITC&quot; at 14pt \rm This is Bradley Hand ITC\\\font\rm=&quot;Nirmala UI&quot; at 14pt \rm This is Nirmala UI\\\font\rm=&quot;CCBackBeat&quot; at 14pt \rm This is CCBackBeat\\\font\rm=&quot;Supercell-Magic&quot; \rm This is Supercell-Magic\\\font\rm=&quot;Supercell-Magic&quot; at 14pt \rm This is Supercell-Magic\\\font\rm=&quot;Supercell-Magic&quot; at 18pt \rm This is Supercell-Magic\\\end&#123;document&#125;``` 显示结果![](https://github-pages-1253649638.cos.ap-beijing.myqcloud.com/post-images/2019/2019-02-22%20-fonts.jpg) ## 设置全局（自定义）字体第二天在测试中发现，用如下代码也能实现同样的效果，现在猜测是刚安装的字体VSCode或XeLaTex识别不了的问题。``` latex\documentclass[UTF8]&#123;article&#125;\usepackage&#123;ctex&#125;\usepackage&#123;fontspec&#125;\usepackage&#123;metalogo&#125;\usepackage&#123;amsmath&#125;\usepackage&#123;newtxtt, newtxmath&#125;\setmainfont&#123;CCBackBeat&#125; %英文字体\setCJKmainfont&#123;DengXian&#125; % 中文字体\title&#123;论文测试&#125;\author&#123;Teemo&#125;\date&#123;2019年2月22日&#125;\begin&#123;document&#125;\maketitle\tableofcontents\section&#123;输出测试&#125; Hello \XeLaTeX. Body of the article. second not sure \\ fuck LaTex \\ 换行试试？\LaTeX，WithTab Icon,How to add a command \\ 换行``` ![](https://github-pages-1253649638.cos.ap-beijing.myqcloud.com/post-images/2019/2019-02-23-font-test-143421.jpg)## 自定义字体``` latex% 定义字体\newcommand&#123;\song&#125;&#123;\CJKfamily&#123;song&#125;&#125; % 宋体\newcommand&#123;\fs&#125;&#123;\CJKfamily&#123;fs&#125;&#125; % 仿宋体\newcommand&#123;\kai&#125;&#123;\CJKfamily&#123;kai&#125;&#125; % 楷体\newcommand&#123;\hei&#125;&#123;\CJKfamily&#123;hei&#125;&#125; % 黑体\newcommand&#123;\li&#125;&#123;\CJKfamily&#123;li&#125;&#125; % 隶书% 定义字号\newcommand&#123;\yihao&#125;&#123;\fontsize&#123;26pt&#125;&#123;36pt&#125;\selectfont&#125; % 一号, 1.4 倍行距\newcommand&#123;\erhao&#125;&#123;\fontsize&#123;22pt&#125;&#123;28pt&#125;\selectfont&#125; % 二号, 1.25倍行距\newcommand&#123;\xiaoer&#125;&#123;\fontsize&#123;18pt&#125;&#123;18pt&#125;\selectfont&#125; % 小二, 单倍行距\newcommand&#123;\sanhao&#125;&#123;\fontsize&#123;16pt&#125;&#123;24pt&#125;\selectfont&#125; % 三号, 1.5倍行距\newcommand&#123;\xiaosan&#125;&#123;\fontsize&#123;15pt&#125;&#123;22pt&#125;\selectfont&#125; % 小三, 1.5倍行距\newcommand&#123;\sihao&#125;&#123;\fontsize&#123;14pt&#125;&#123;21pt&#125;\selectfont&#125; % 四号, 1.5 倍行距\newcommand&#123;\banxiaosi&#125;&#123;\fontsize&#123;13pt&#125;&#123;19.5pt&#125;\selectfont&#125; % 半小四, 1.5倍行距\newcommand&#123;\xiaosi&#125;&#123;\fontsize&#123;12pt&#125;&#123;18pt&#125;\selectfont&#125; % 小四, 1.5倍行距\newcommand&#123;\dawu&#125;&#123;\fontsize&#123;11pt&#125;&#123;11pt&#125;\selectfont&#125; % 大五号, 单倍行距\newcommand&#123;\wuhao&#125;&#123;\fontsize&#123;10.5pt&#125;&#123;15.75pt&#125;\selectfont&#125; % 五号, 单倍行距\newcommand&#123;\xiaowu&#125;&#123;\fontsize&#123;9pt&#125;&#123;9pt&#125;\selectfont&#125; % 小五, 单倍行距\hei\xiaosan\textbf&#123;实验代码&#125; % 黑体小三加粗 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>LaTex</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>LaTex</tag>
        <tag>字体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件及开发包安装中的那些坑]]></title>
    <url>%2F2019%2F02%2F22%2F2019-2-22-software-installation-description%2F</url>
    <content type="text"><![CDATA[先把坑都踩一遍是为了以后踩更多的坑。 latexindent 来自：安装LaTex-formatter需要安装的工具 方式：解压缩，（可数的）文件直接拖入目录 目录：C:\Program\texlive\2018\texmf-dist\scripts\latexindent 文件：latexindent.exe 使用方式：选中代码->右键格式化选定内容 注：更改了该目录下的defaultSettings.yaml的某些设置 1234567891011121314151617181920212223242526# line222~line246indentAfterHeadings: part: indentAfterThisHeading: 1 level: 1 chapter: indentAfterThisHeading: 1 level: 2 section: indentAfterThisHeading: 1 level: 3 subsection: indentAfterThisHeading: 1 level: 4 subsection*: indentAfterThisHeading: 1 level: 4 subsubsection: indentAfterThisHeading: 1 level: 5 paragraph: indentAfterThisHeading: 1 level: 6 subparagraph: indentAfterThisHeading: 1 level: 7 ruby-jekyll大佬Pchou的博客 安装Ruby with Devkit，所有组件都在这里了，注意安装路径不要出现空格 ruby安装完，会提示安装MSYS2，跟着提示走就好。现在新版本的Ruby已经集成了RubyGems 环境安装好就可以安装Bundle和Jekyll了（gem install jekyll），但是在今天（2019-2-22）安装的过程中发现bundle是安装环境是已经安装好了的。 到博客目录下依次执行以下命令：123bundle installbundle updatebundle exec jekyll serve 关于ryby及Jekyll的某些错误 jekyll 3.7.4 | Error: incompatible character encodings: UTF-8 and GBK不知道如何解决，尝试设置命令行字符编码chcp 65001（不行）已知的可能解决方法：设置 -> 时间和语言 -> 区域 -> 更改日期、时间或数字格式 -> 管理 -> 更改系统区域设置：选中“使用Unicode UTF-8 提供全球语言支持”，然后重启电脑，应该就解决了。 执行bundle命令时出现C:/Program/Ruby25-x64/lib/ruby/2.5.0/rubygems.rb:289:in 'find_spec_for_exe': can't find gem bundler (>= 0.a) with executable bundle (Gem::GemNotFoundException)，在StackOverflow上找到答案：Gemfile.lock文件最后的BUNDLED WITH版本改为已安装的bundler版本。或者删除Gemfile.lock文件，重新bundle exec jekyll serve VSCode中C/C++找不到头文件可能需要设置这些环境变量： 123456789101112LIBRARY_PATHC:\Program\mingw64\lib\gcc\x86_64-w64-mingw32\7.3.0C_INCLUDE_PATHC:\Program\mingw64\include;C:\Program\mingw64\lib\gcc\x86_64-w64-mingw32\7.3.0\include;CPLUS_INCLUDE_PATHC:\Program\mingw64\include;C:\Program\mingw64\lib\gcc\x86_64-w64-mingw32\7.3.0\include\c++;C:\Program\mingw64\lib\gcc\x86_64-w64-mingw32\7.3.0\include\c++\backward;C:\Program\mingw64\lib\gcc\x86_64-w64-mingw32\7.3.0\include\c++\x86_64-w64-mingw32; CUDA cuDNN复制cuDNN到CUDA目录 123C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0\bin\cudnn64_7.dllC:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0\include\cudnn.hC:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0\lib\x64\cudnn.lib document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Software</category>
      </categories>
      <tags>
        <tag>GitHub Pages</tag>
        <tag>笔记</tag>
        <tag>LaTex</tag>
        <tag>C/C++</tag>
        <tag>CUDA</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[睡前小故事——Day 4]]></title>
    <url>%2F2019%2F01%2F23%2Fshort-stories-before-bed4%2F</url>
    <content type="text"><![CDATA[来自知乎的暖心故事 知乎用户-行歌原文链接 一、 嘎嘣豆是宠物店里最调皮的仓鼠。 它每天晚上都能悄悄的打开自己的笼子逃出来，跑到嘎嘣脆的笼子里一头拱进食盒里大吃特吃。 嘎嘣脆是宠物店里最不爱动弹的猫。 它每天只干三件事，吃饭，睡觉，看嘎嘣豆吃它的猫粮。 二、 “我很想知道，老板是不给你饭吃吗？”某天晚上嘎嘣脆看着挣扎在猫粮里的嘎嘣豆，一脸同情。 “当然不是！”嘎嘣豆挥舞着小短腿费了半天的功夫才从食盒里坐起来，“我只是很喜欢猫粮的味道好的吧。” “所以你吃成了一个球。”嘎嘣脆一脸嫌弃的伸出他高贵的猫爪子，戳了戳他圆滚滚的肚子。 三、 嘎嘣脆是宠物店里最挑食的猫，他不喜欢吃一粒一粒硬邦邦的猫粮。 “廉价的混合物配不上我高贵的胃。” 这是他的原话，虽然他说完之后遭到了隔壁英短无情的嘲笑。但是，王要有王的尊严，也要有王的气度。 所以嘎嘣脆也不屑于计较，但是因为挑食他一天到晚都懒洋洋的，毛也没有光泽。 来店里买猫的顾客走了一拨又一拨，身为高贵的布偶猫他却迟迟没能被挑中。 “这只猫不会得了什么病吧？”顾客跟店员窃窃私语。 四、 嘎嘣豆是宠物店最调皮的仓鼠。 自从他学会了越狱，每天晚上就孜孜不倦的去拜访隔壁，美其名曰增进感情。 他去吃嘎嘣脆的猫粮是有代价的，他把一条条的小鱼干鱿鱼干拖进嘎嘣脆的笼子里，好进行平等的交流互换。 嘎嘣脆在天天夜宵的滋补下精神见好，毛也逐渐变得光滑。 五、 嘎嘣豆是宠物店里最胖的仓鼠。 嘎嘣脆是宠物店里最漂亮的猫。 “都说了给它少喂一点！怎么还是这么胖！” 嘎嘣豆依然天天晚上过来吃猫粮，只是吃完之后要回去多跑几遍跑轮。 嘎嘣脆咬着小鱼干忍不住问他：“跑跑轮累不累呀？” “嘿呀都累死鼠了。”嘎嘣豆躺在食盒里，四只小爪伸展开瘫成一个大字。 “什么时候他们能给你你换一个口味的猫粮啊，我吃的都要吐了呢。”嘎嘣豆捂着自己鼓鼓的腮帮子，叹了口气。 六、 嘎嘣豆从那一天开始再也不过去吃猫粮了。 因为嘎嘣脆伸出他的桌子拍了拍嘎嘣豆的头。 “那个，老鼠，你说实话，你是不是根本不喜欢吃猫粮。” “不要叫我老鼠！我是仓鼠！仓鼠！仓鼠！而且我有名字！嘎嘣豆！” “额……好吧……嘎嘣豆。。” 暴跳如雷的小仓鼠叉着腰瞪着他：“这还差不多……猫粮……猫粮还好吧。。” 嘎嘣脆若有所思：“他们是不是说我不吃饭肯定是得病了要关起来？” 小仓鼠不说话，瞪着黑色的小眼珠看着他拼命的眨。 七、 嘎嘣豆一直是一只乖巧的小仓鼠，他懂事以来的日常就是越狱和欺负不爱吃饭的病猫嘎嘣脆，有一次他好奇尝了一口猫粮，咸滋滋，好难吃。 直到有一天他越狱跑到休息室，听到老板说，那只病歪歪的猫再不见好就先关到后院吧。 噫，后院都是攻击性强没人肯要的宠物，嘎嘣豆打了个哆嗦。 那一天开始嘎嘣豆开始费尽心思的去偷储藏室里的小鱼干给嘎嘣脆吃，顺便要消灭他挑食的证据，一大碗猫粮也要毁尸灭迹。 怎么办呢，只能吃掉。 八、 嘎嘣脆终于改掉了挑食的坏毛病，他越来越健康，长的也更加漂亮，店主开心的要拿小鱼干奖励它，打开柜子却发现里面空荡荡。 真傻。 嘎嘣豆隔着笼子，对他挤眉弄眼的笑。 特别喜欢这个系列的仓鼠嘤嘤嘤 知乎用户-挽挽酱原文链接 一个女孩让我帮她寄快递， 给了我一个空纸箱让我打包。 我好奇的问她: “这是寄给谁的?” 她说:”喜欢很久的男生。”我懵了一下: “可是里面没有东西啊。” 她说:”有些东西，只有我自己能看见。” 我一听更懵逼了， 神秘地问她到底是什么。 她说:”一箱情愿。” 后来， 男生把一个箱子还给了她。 两箱情愿，一箱欢喜。 Best wishes！( ´罒`*)✧” document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>睡前小故事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[睡前小故事——Day 5]]></title>
    <url>%2F2019%2F01%2F23%2Fshort-stories-before-bed5%2F</url>
    <content type="text"><![CDATA[来自知乎的暖心故事 知乎用户-川戈原文链接 1、 书生觉得自己倒霉透了。 进京赶考的路上，书生看到了一群山贼正在打劫车队。饱读诗书的他立刻上前仗义执言，训得匪徒哑口无言。 “现在收手还来得及，否则我立刻就去报官！你们可以保持沉默，但你们说的每一句话，都将成为呈堂证供！”书生指点江山，意气风发。 “你说得对！”为首的蒙面人诚恳地说，“我的确没考虑到这一点。” 书生昂首挺胸，心想最近自己果然口才大有进步，却突然听到了蒙面人的一句话。 “小的们，把这个书生一块儿绑回去，灭口！” 2、 书生昂首挺胸，心想最近自己果然口才大有进步，却突然听到了蒙面人的一句话。 “小的们，把这个书生一块儿绑回去，灭口！” “喂，那个书生，我看你下午那番话，有几分歪才，留寨子里当个军师如何？” 书生挺直了腰，面无惧色：“劫生辰纲的事不怪你们，但想让我同流合污，没门！” 美娇娘嫣然一笑：“那就柴房里关着，关到同意为止呗！” 书生这下急了，进京赶考可耽误不得啊！他连忙服软：“这位大王……” 谁知美娇娘突然翻了脸，狠狠弹了书生一个脑瓜崩，疼得他流出眼泪来。 “不要叫我大王，要叫我女王大人！” 3、 小喽啰们发现，寨主最近特别爱往柴房跑。 本来只想劝书生在山寨入伙，但聊着聊着，美娇娘却发现，和书生聊天太他娘的有意思啦！ “你这样不好，”书生皱起了眉头，“【他娘的】，这是脏话，女孩子家，要温柔才像样！” “温柔？那是弱女子才干的事儿！我可是要当巾帼英雄的人！”美娇娘柳眉一竖，就要发火。 “谁说女英雄就要讲脏话！你知道花木兰吗？你知道穆桂英吗？梁红玉、樊梨花、聂隐娘……” 美娇娘的眼睛里逐渐冒出了小星星：“你懂的好多，快给我讲讲！” 书生得意一笑：“行，那我就给大王你讲讲……” “啪”一个脑瓜崩弹在了书生脑门上。 “说了多少次，不要叫我大王，要叫我女王大人！” 4、 美娇娘逐渐成了书生的迷妹，他的住处啊，从柴房变成了厢房。 这天，美娇娘推开了书生的房门：“我仔细想过了，你的确不适合当我的军师。” 书生喜出望外：“这么说，我可以下山了？” 美娇娘摇了摇头：“我觉得，你还是当我的压寨夫君更好一点。” 书生两眼一黑，差点晕了过去。虽然美娇娘长得好看，心眼不坏，劫富济贫也算个侠盗，对自己也很好——可她是个山贼啊，我家书香门第，怎么能嫁给山贼呢？ 啊呸，我怎么能用“嫁”这个字，应该是“娶”才对。 书生摇了摇头：“对不起，我心仪的姑娘，必须知书达理，才华胜过我才行。” 美娇娘丹凤眼一瞪：“武功胜过你行不行？” 书生一咬牙，闭上了眼睛：“宁为玉碎不为瓦全！” 5、 “不就是才华吗？我现在就去读书！”美娇娘一言不发出了院子，连夜绑来了城里的老秀才，悬梁刺股苦读了三天三夜，“我就不信我学不来！” 第四天，她叹着气踹开了书生的房门：“算了，读书太难了，你还是下山吧。” 书生临走时，突然觉得有些难过。他犹豫了片刻，还是回过头说了一句：“青山不改，绿水长流。大王，后会有期！” “说了不要叫我大王……”美娇娘拳头刚举起来，又突然停住，背过了身子悄悄擦泪，“算了，随你怎么叫吧。” 6、 书生一进城，就被官兵抓了起来。 原来，有人举报他是山贼的同伙，一起劫了生辰纲。书生无处伸冤，直接关进了大牢，赶考的事儿也泡了汤。 问斩前一天晚上，火光大作，嘈杂万分。牢房大门被一刀劈开，一道人影进来，背着书生就走，一路杀出重围，回了山寨。 书生这才注意到，原来救自己的，是美娇娘。 看着她一身是伤，却依然笑颜如花，书生叹了口气：“没办法，这下只能当你的狗头军师了。” “只是军师而已吗？”美娇娘有些失望，“难道一定要才华胜过你，才肯当我压寨夫君？” “唉，真拿你没办法，”书生无奈地叹了口气，“明天开始，我教你读书。” 7、 书生半夜出来赏月，无意中听到美娇娘在和老秀才商量什么。 “读书太难了，有没有快一点的办法？” …… “我明白了，这就证明，他的才华远不如我，他就只能乖乖从了我！” 听着美娇娘豪迈大笑，书生冷哼一声。 我凭本事单的身，想作弊？不可能！ 8、 第二天，美娇娘坏笑着推开书生的门：“喂，我来考考你，若是答错了，你便乖乖从了我！” 书生一摆手：“出招吧。” “你写个回字出来。”“回字有四种写法，大王，你要的是哪一种？” 美娇娘一愣：“算了算了，你还是画个龙给我看看。” 书生得意一笑：“龙有虺虬螭蛟多个品种，大王，你要看哪样？” 美娇娘抓耳挠腮，涨红了脸，原地踱了两圈，突然一拍桌子，拽着书生把他推倒在卧室的床上。 “说了多少次，叫我女王大人！” document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>睡前小故事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[睡前小故事——Day 3]]></title>
    <url>%2F2019%2F01%2F22%2Fshort-stories-before-bed3%2F</url>
    <content type="text"><![CDATA[来自知乎的暖心故事 知乎用户-Wangshiyin原文链接 1. 有一天，小鱼问大鱼：大…鱼…大…鱼，你…喜…欢…吃…什…么…样…的…小…鱼…呀…？ 大鱼说：我…喜…欢…吃…讲话…慢…的…小…鱼…， 小鱼说：哦我造了。 2. 两只小蜜蜂呀。飞到花丛中。一只飞得高，一只飞得低。 飞得高的那只对飞得低的那只说：“你这只low bee” 3. 为什么海水是蓝色的呀。 因为海洋里有很多小鱼 它们会：blue blue blue ～ 知乎用户-关山月原文链接 (◕ˇ∀ˇ◕)谢谢大家捧场。。 1. 有一个长得特别胖的柠檬，别的柠檬都是椭圆的，尖尖的，可是他却特别圆，跟小和尚的头似的。 他特别的苦恼！于是每天不喝水，不吃饭的减肥，想把自己饿瘦成别的柠檬的样子。 但是到了别的柠檬都变黄了，成熟了，他还是那么胖 于是他就等啊等饿啊饿，立志把自己饿得那么瘦才成熟。 直到很久很久以后。。他才发现。。。自己。。。原来。。。是个柚子(≖_≖ ) 2. 她偷偷用小号拜了男神为师父 整天问他 “师父，我该把眼插在哪？” “师父，我该什么时候放大？” 男神不太懂辅助位置怎么打，每次都支支吾吾打发过去。 直到有一天，她问了好多问题男神糊弄不过去了，就说，“徒儿你等等，我问问你师娘。” 这一刻她觉得自己竟卑微的可怜。 没过多久QQ大号响起 是男神问她 “在吗？那个。。你会玩辅助吗。。？” 3. 有个小仙女喜欢把云朵捏成各种各样的形状 这天她捏出了一群动物花草，却又突然一挥手把他们打散了 路过的蝴蝶问她: “你为什么不开心啊？” 仙女说: “没有朋友和我一起玩。” 蝴蝶说: “管风的小神仙喜欢你很久了” 仙女奇怪的问： “你怎么知道？” 蝴蝶默默的笑着说： “要不你以为你每次捏云朵的时候，为什么从来没有破坏的风”( ﹡ˆoˆ﹡ ) 4. 5. 6. 7. 8. 9. 唉。。差点忘记说了(⋟﹏⋞)故事来源于网络且是多年收藏，图片呢来自微博，已经是规范转载了！那就请各位小可爱们！别再举报了！做人！要厚道呀！ 喜欢吗?。。喜欢。。。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>睡前小故事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[睡前小故事——Day 2]]></title>
    <url>%2F2019%2F01%2F20%2Fshort-stories-before-bed2%2F</url>
    <content type="text"><![CDATA[来自知乎的暖心故事 知乎用户-泊安原文链接 小公主喜欢上了小木匠 小木匠认真的在为小公主打造梳妆台 小公主托着腮趴在旁边 眼里都是小星星 小木匠把梳妆台做完了 小公主不舍得小木匠走 “可以让梳妆台有一颗粉红色的心么” “我还想要一个双层的大大的首饰盒” “还有，还有，你可以给我做一个木头的小兔子么” 小木匠点点头 小木匠叮叮当当做了一个呆呆的小兔子 又叮叮当当做了一个漂亮的首饰盒 小木匠把小兔子递给小公主小公主抱着小兔子，摸摸首饰盒 “你还没有给我做粉红色的心呢” 小木匠撇撇嘴 “我的心已经给你了，你为什么还要心呢” 小公主眨眨眼 “你什么时候把心给我了”“你给我星星的时候” 知乎用户-乔小巴原文链接 故事一.偷偷地想你O(∩_∩)O吃饭篇~ 大兔子和小兔子一起吃饭。小兔子捧着饭碗，对大兔子说：“想你。” “我不就在你身边吗？”大兔子说。 “可我还是想你。”小兔子咂吧咂吧嘴，“我每吃一口饭都要想你一遍，所以，我的饭又香又甜，哪怕是我最不喜欢的卷心菜。” 大兔子不说话，只是低着头继续吃饭。 散步篇~ 大兔子和小兔子一起散步。 小兔子一蹦一跳，对大兔子说：“想你。” “我不就在你身边吗？” 大兔子说。“可我还是想你。” 小兔子踮起脚尖，“我每走一步路都要想你一遍，所以，再长的路走起来都轻轻松松，哪怕路上满是泥泞。” 大兔子不说话，只是慢悠悠地继续走路。 看月亮篇~ 大兔子和小兔子坐在一起看月亮。 小兔子托着下巴，对大兔子说：“想你。” “我不就在你身边吗？”大兔子说。 “可我还是想你。”小兔子歪着脑袋，“我每看一眼月亮都要想你一遍，所以，月亮看上去那么美，哪怕乌云遮挡了它的光芒。” 大兔子不说话，只是抬起头继续看月亮。 睡觉篇~ 大兔子和小兔子该睡觉了。 小兔子盖好被子，对大兔子说：“想你。” “我不就在你身边吗。”大兔子说。“可我还是想你。”小兔子闭上眼睛，“我每做一个梦都要想你一遍，所以，每个梦都是那么温暖，哪怕梦里出现妖怪我都不会害怕。” 大兔子不说话，躺到床上。 想你篇~嘘… 小兔子睡着了，大兔子轻轻亲吻小兔子的额头。 “每天每天，每分每秒，我都在想你，悄悄地想……” 故事二.我爱你，要比你爱我更多更长~嘘……(^__^)小兔子要上床睡觉了， 它紧紧抓著大兔子的长耳朵，要大兔子好好地听它说。 “猜猜我有多爱你？”小兔子问。 “噢！我大概猜不出来。”大兔子笑笑地说。 “我爱你这么多。”小兔子把手臂张开，开得不能再开。 大兔子有双更长的手臂，它张开来一比，说：“可是，我爱你这么多。” 小兔子动动右耳，想：“嗯，这真的很多。” “我爱你，像我举的这么高，高得不能再高。”小兔子说，双臂用力往上撑举。 “我爱你，像我举的这么高，高得不能再高。”大兔子也说。 哦，小兔子想，真糟，他又比我高。 小兔子又有个好主意，它把脚顶在树干上倒立了起来。它说：“我爱你到我的脚趾头这么多。” 大兔子一把抓起小兔子的手，将它抛起来，飞得比它的头还高，说：“我爱你到你的脚趾头这么多。” 小兔子大叫：“我爱你，一直到过了小路，在远远的河那边。” 大兔子说：“我爱你，一直到过了小河，越过山的那一边。” 小兔子想，那真的好远。它揉揉红红的两眼，开始困了，想不出来了； 它抬头看著树丛后面那一大片的黑夜，觉得再也没有任何东西比天空更远的了。 大兔子轻轻抱起频频打著呵欠的小兔子，小兔子闭上了眼睛，在进入梦乡前，喃喃说：“我爱你，从这里一直到月亮。” “噢！那么远，”大兔子说。 真的非常远、非常远。 大兔子轻轻将小兔子放到叶子铺成的床上，低下头来，亲亲它，祝它晚安。 然后，大兔子躺在小兔子的旁边，小声地微笑著说：“我爱你，从这里一直到月亮，再绕回来。” document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>睡前小故事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[睡前小故事——Day 1]]></title>
    <url>%2F2019%2F01%2F19%2Fshort-stories-before-bed1%2F</url>
    <content type="text"><![CDATA[来自知乎的暖心故事 知乎用户-芒果原文链接 “爷爷，学校里同学说世界上没有龙没有妖怪什么都没有，都是别人编的。”少女坐在爷爷身边，嘟着嘴抱怨到。 “别听他们的，丫头，这个世界上明明就有啊，不仅有龙，还有勇敢的骑士，能驯服龙的骑士。”爷爷布满皱纹的手轻抚着少女的头发，眼里满满都是慈爱，“但是龙骑士是很骄傲的，他只会出现在相信他的人的世界里。” “可是，我怎么跟他们解释，他们都不信，说我骗人，笑我幼稚长不大。”女孩几乎快哭出来了 “去睡吧，丫头，明天起来，大家就会相信你了。”爷爷看着少女落寞回房的背影，好像下定了什么决心。 “去哪儿老头子？”奶奶听到大门打开的声音，从房间里走了出来。 “去见一个老朋友，好多年没见了，想跟它好好叙叙旧。”爷爷说着别了别腰间锈迹斑斑的铁剑。 “你啊，从以前就是暴脾气！待会儿可别吓着那些小家伙了，他们毕竟还是孩子。”奶奶转身回房，出来的时候手上拿着一条破旧的有点褪色的披风，一边嗔怪着，一边给爷爷系上。 “我心里有数，这些小鬼竟敢嘲笑囡囡，看我今天不好好收拾他们！”爷爷忿忿不平的唠叨着，头也不回的出门了。 那天晚上，几乎全城的人都看到一头巨大的飞龙在雪白的月光下呼啸而过，龙背上依稀有个人影，拿着剑，背后的披风猎猎作响，奶奶也在窗口看着那巨龙咆哮腾飞，一如当年那个少年，也是这样手执长剑，布衣披风，骑着巨龙从天而降，长笑不羁，神采飞扬。 知乎用户-曹丰泽原文链接 在不久以前，大约四千年吧。那时还没有国家，人类生活在部落里。在文明的西部边缘，有一个部落。部落的名字已经不得而知，我们就叫它二狗子寨吧。 那时，天气逐渐转冷，庄稼收成不好，他们养的猪也被吃光了。二狗子寨的男人们只好出去打猎。家里没有牲畜需要照料，死孩子也都已经装进了陶罐里，女人们只好蹲在寨子门口唠闲嗑，并祈祷男人们能打到鹿回来。 天气阴沉沉的，部落里的祭司说要有不好的事情发生。因此，蹲在寨子门口唠闲嗑的女人们都抱着孩子回家了。她们用仅剩的小米磨碎做成面条，放在锅里煮好，等待男人回家。我编不下去了，总之大洪水冲进了这块德性的洼地，他们住的这种半地穴式建筑瞬间被水淹没，女人们把孩子护在身下，然后被埋进了河水带来的泥土之中，直到四千年后考古队员将她们和孩子们挖了出来。就像这样。 你看，女人们的本能啊，是多么的令人动容。她们生命的最后一刻想的，就是保护她们的孩子啊。所以我们什么时候开始造娃 知乎用户-有很多人原文链接 黄小狼刚出生没多久，妈妈嫌弃他毛色难看，就把他赶出家门自生自灭去了。真是糟糕，黄小狼还不会人生最重要的技能—偷鸡呢。 他实在饿的不行了，穿过树林，偷偷来到了村里的农户家，准备看看有没有机会可以逮着一只鸡。他悄悄地躲在门口的树后，看着院子里一只油亮亮、毛皮鲜亮光鲜的大公鸡顶着鲜红的鸡冠，骄傲地迈着步伐，在院子里仿佛巡视领地一般走了走去。 大公鸡眼尖，发现了他，一点也不害怕，突然立起了脖子边的毛，如同离弦的箭一样射了过来，要啄黄小狼。于是，两人开启了追逐战。 时间日复一日地划过，黄小狼每天都要去找大公鸡锻炼自己抓鸡的本领。可是在一个阳光灿烂的午后，美丽的大公鸡不见了。或者说让大公鸡骄傲的毛皮不见了。原来大公鸡的毛被农户扒走做了鸡毛掸子。他靠近被拔了毛的大公鸡，大公鸡也没像以前一样奋起直追，而是有些恹恹地撇了他一眼，跺着步伐走开了。 第二天，黄小狼叼着鸡毛掸子又来找大公鸡了。他一身是伤，昨天趁夜偷鸡毛掸子地时候惊醒了农户，黑灯瞎火地挨了几下打。 黄小狼甩了甩他秃秃地尾巴，讨好地对大公鸡笑了笑：你看，我进步啦，起码学会了偷鸡毛。大公鸡梗着脖子半晌，突然把头凑近了黄小狼，黄小狼以为大公鸡又要啄他。吓得闭了眼，大公鸡却只是用尖尖地嘴小心的、轻轻地蹭了他一下。 知乎用户-李阿木原文链接 “亲爱的，我昨晚做了一个梦，梦见一个很大很大的池塘喔，里面有一条小金鱼和一朵小荷花快乐地生活着。” “哇，有多大呀？” “恩，大概跟我们家一样大吧” “那也没有很大呀…” “将来会很大的喔！” “嗯～”“故事开始洛…” (第一天) 风清月朗，星光洒满了湖面。 小金鱼在小荷花的周围游来游去，欢快地打着滚，吐着泡泡。 小荷花站在水里，一会看看天上的月亮，一会看看水里的月亮，心里开心极了。 小金鱼游呀游，也不知道游了多少圈，终于忍不住上前打了声招呼： “你好呀，小荷花。” “你好呀，小金鱼。”小荷花笑着摆了摆手，说：“你看今晚的月光好美呀！” 小金鱼抬头看了看月亮，又看了看小荷花，不由地摇起了尾巴，开心了起来。 (第二天) 春风温柔，浅浅地吹着湖面。 小金鱼在小荷花的周围游来游去，欢快地打着滚，吐着泡泡。 小荷花嘻嘻笑着，欢快地拍着手，她还从来没有见过这么可爱会吐心形泡泡的小金鱼呢。 吐完了泡泡的小金鱼，又变成了正经的小金鱼，他会一本正经地问：“喂，小荷花，你看着我干什么，你是不是想亲我呀？” 小荷花羞红了脸，气哼哼地不理小金鱼。 小金鱼又围着小荷花游来游去，一会打滚，一会倒立，一会吐泡泡。 小荷花被小金鱼气笑了，瞪了他一眼，问： “你看着我干什么？你是不是想亲我呀？” 小金鱼点了点头，很认真地看着小荷花，说：“是呀！想了好久了！” 然后小金鱼跳起来，亲了小荷花一下。 天边的晚霞一不小心就飞到了小荷花的脸上。 (第三天) 阳光温柔，天空中偶尔有白云飘过。 小金鱼在小荷花的周围游来游去，欢快地打着滚，吐着泡泡。 “喂，小金鱼，你昨天为什么要亲我呀？” “嘿嘿，我想跳都跳了，不亲一下不是白跳了吗” 小金鱼吐完一串心形泡泡，欢快地摇起了尾巴。 “喂，小金鱼，我跟你说你不可以像昨天那样随便亲女孩子喔！”小荷花瞪着眼睛，气哼哼地说道。 “喂，跳起来也是很累的，我怎么可能随便亲别人喔！” “哼！你肯定也偷偷亲过别人，不理你啦”小荷花气哼哼地转过头去。 小金鱼于是又围着小荷花游来游去，一会打滚，一会倒立，一会吐泡泡。 “喂，小荷花，你再不理我，我又要跳起来给你一个么么哒洛。” “扑哧！”香气弥漫了整个湖面。 (第四天) 柳絮温柔，漫天地飘荡着。 小金鱼在小荷花的周围游来游去，欢快地打着滚，吐着泡泡。 小荷花被心形的泡泡环绕在中间，一会看看湖面上飘荡的柳絮，一会看看小金鱼，笑弯了腰。小金鱼欢快地摇着尾巴，时不时跳起来就给小荷花一个么么哒。 “喂，你整天跳来跳去不累吗？” “喜欢你怎么会累？” (第五天) 细雨温柔，在湖面上点出涟漪。 小金鱼在小荷花的周围游来游去，欢快地打着滚，吐着泡泡。 “小金鱼，下雨了喔，今晚看不到月亮了。” 雨越下越大，雨点在湖面上跳跃着，好像一闪一闪的星空。 小金鱼在水里吐着泡泡，抬头看见雨中的小荷花，像极了初见时那晚的月光，洁白淡雅。 “不会呀，今晚月光很美！”小金鱼看着小荷花，认真的说。 小荷花也看着小金鱼，那个雨夜香气四溢。 (第六天) 大雨倾盆也温柔，池塘水位上涨，小荷花也浮在了水面上。 小金鱼在小荷花的周围游来游去，欢快地打着滚，吐着泡泡。 “小金鱼，有你真好，下雨天我也可以很开心。” “小荷花，其实我有点喜欢下雨天啦！” “你是鱼耶当然喜欢下雨天啦！” “不是的！”小金鱼游到了小荷花的身边，拉着她的手温柔地说道：“因为下雨天呀，我不用跳就可以亲到你了！” 说完，小金鱼就抱着小荷花亲了一下，满满的爱意从鼓鼓的眼睛溢了出来。 (第七天) 亲爱的，余生还很长，我们不必急着一晚上把故事都听完，乖，来睡觉觉了，我们睡着了，小荷花和小金鱼就又可以在一起了呀，乖啦！ 女：嘻嘻，好的吧，不过你要告诉我为什么你是小金鱼我是小荷花咧？ 男：因为这样，我就可以游到你的心底了呀！ 女：嘻嘻，那我也要去你的心底呀！ 男：被辣么多心形泡泡环绕，你以为你还跑的掉！ 晚安，写给女票的睡前小故事。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>睡前小故事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[年记——一月]]></title>
    <url>%2F2019%2F01%2F19%2Ffirst-month%2F</url>
    <content type="text"><![CDATA[January 第一周2019.1.1 元旦 大晚上和懒子还有他可爱的大一妹子吃鸡，截图。 习主席的新年贺词 2019.1.2 今天毕业论文开题 这是做的PPT 打印开题报告出来，看到了一只小松鼠，但是没拍到 2019.1.3 今天回家了 和狗子们出来吃饭，但只拍到一个，不知道是不是最后一次 狗哥的白葡萄酒，被我和山东、内蒙的瓜分 第二周中间回家好几天没拍照…… 2019.1.7 超市 和我爸去上官超市买的黄豆和各种米，遇见了我奶奶、我妈、我姨 2019.1.8 周总理逝世43周年 周总理逝世43周年，谨记。感谢周总理 黑豆 茏茏给黑豆拍的照，总感觉它巨乖；有小窝之前【可怜 😑 】 VS 有小窝之后【舒呼 😬 】 2019.1.9 她忘了我的样子，居然 这就是我 这是给黑豆吃的打虫药，肠虫清 春妹老师给我的任务，百十张图片硬是手动截完了，然后收获了一句“好” 2019.1.10 科普 逛知乎随手下载的素材，纯当科普 2019.1.11 给我妈拍照 公告栏上要用，那个王八蛋打电话要，觉得等不及了就自己拍了，那晚他俩看起来都不开心 2019.1.13 二姑 想要一个高一点的桌子，网上的看起来总觉得有点低（其实并不低，后来我觉得），然后我二姑让我去他家，说给我做。其实就是住了两三天，除了睡觉干活的时候暖和，基本上都在瑟瑟发抖。这是在烧水的时候给明明拍的照（我就是当素材拍的）。 第三周2019.1.15 蚂蚁森林 蚂蚁森林的敖特根大叔和2019第一小生命——小牛的合照 2019.1.17 逗我爸开心，给他玩我妈刚买来的被子固定器。 2019.1.18 我今天炒的炒饭，嗯，味道真的可以 第四周 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>年记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python pyinstaller的使用]]></title>
    <url>%2F2018%2F03%2F16%2Fhow-to-use-pyinstaller%2F</url>
    <content type="text"><![CDATA[I think of others ages that floated upon the stream of life and love and death and are forgotten, and I feel the freedom of passing away.我想起了浮泛在生与爱与死的川流上的许多别的时代，以及这些时代之被遗忘，我便感觉到离开尘世的自由了。 泰戈尔飞鸟集 概述安装: pip install pyinstaller 用法: pyinstaller -options script.py，等 pyinstaller 编译完成之后，目录里面就多出两个文件夹: build 和 dist，其中 dist 里面就是打包的二进制文件，build 里是编译过程生成的中间件（作用不明） 选项 | 作用-w，–windowed，–noconsole | 窗体exe文件(Windows Only)-c，–nowindowed，–console | 控制台exe文件(Windows Only)-F，–onefile | 把脚本打包成一个独立文件，打包一时爽，打开花五秒-o DIR，–out=DIR | 设置spec文件输出的目录，默认在PyInstaller同目录–version-file=file_version_info.txt，-v file | 给程序添加版权信息，需要指定一个版本信息文件–icon=ico.ico | 添加图标，必须是 ico 文件–upx-dir | 压缩可执行程序 版权信息在我的GitHub里有现成的版权信息文件: “file_version_info.txt”，修改后即可使用。传送门利用 pyinstaller 内置的 grab_verson.py 或 pyi-grab_version.exe工具也可以自己获取其他 exe 文件的版权信息，修改后使用。 grab_version.py: 目录:“Python27\Lib\site-packages\PyInstaller\utils\cliutils”，用法: python grab_version.py exe-file pyi-grab_version.exe: 目录: “Python27\Scripts\pyi-grab_version.exe”，用法: pyi-grab_version exe-file version-file 举个栗子说明: exe-file（C:\Users\Sarmon\AppData\Local\GitHubDesktop\GitHubDesktop.exe），version-file（version.txt） 版权信息文件中，#号起注释作用，如果生成的 version.txt 没有正确换行，在修改的时候需要注意正确区分注释与版权信息 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>pyinstaller</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hive 数据类型]]></title>
    <url>%2F2018%2F02%2F06%2Fhive-type-of-data%2F</url>
    <content type="text"><![CDATA[I cannot tell why this heart languishes in silence. It is for small needs it never asks, or knows or remembers.我说不出这心为什么那样颓丧着，是为了它那不曾要求，不曾知道，不曾记得的小小的需要。 泰戈尔飞鸟集 基本数据类型未完待续…… 复杂数据类型关系型数据库强烈不建议重复存储我们接触过的大数据数据库比如 Hbase、Hive 不怕重复，但要求的是存储数据的文件不要太小。 类型 | 说明 | 举例Array （数组） | 一组数据类型相同的值 | [1,2,3]Map（集合）| 一组 ，要求所有键类型相同，所有值类型相同 | {, }Struct（结构） | 一组不同字段，且每个字段的类型可以不同 | (“str”, 1, 0) 数组假如我们有以下数据： 在 Hive 里创建一个表： 1234567CREATE TABLE loginArray(ip STRING,userid ARRAY&lt;BIGINT&gt;)ROW FORMAT DELIMITED FIELDS TERMINATED BY ','COLLECTION ITEMS TERMINATED BY '|'; 然后导入数据：` LOAD DATA LOCAL INPATH ‘/home/user/test_data/login_array.txt’ INTO TABLE loginArray12345678910111213141516171819202122232425262728293031323334353637查询数据：`SELECT id,userid FROM loginArray`![](https://github-pages-1253649638.cos.ap-beijing.myqcloud.com/post-images/2018-02-06-array-id-userid.jpg)指定数组元素查询：`SELECT id,userid[0] FROM loginArray` ![](https://github-pages-1253649638.cos.ap-beijing.myqcloud.com/post-images/2018-02-06-array-ip-userid%5B1%5D.jpg.jpg)查询数组长度（-1为空）：`SELECT size(userid) FROM loginArray`![](https://github-pages-1253649638.cos.ap-beijing.myqcloud.com/post-images/2018-02-06-array-length.jpg)### 集合#### 标准数据表处理给定测试数据：![](https://github-pages-1253649638.cos.ap-beijing.myqcloud.com/post-images/2018-02-06-map-1.jpg)数据表示某用户(id)，在某 IP 的主机上玩了哪些游戏以及游戏次数开始建表：``` sqlCREATE TBALE loginmap(IP STRING,userid BIGINT,gameinfo MAP&lt;STRING, INT&gt;)ROW FORMAT DELIMITED FIELDS TERMINATED BY &apos;,&apos;COLLECTION ITEMS TERMINATED BY &apos;|&apos;MAP KEYS TERMINATED BY &apos;:&apos;; 导入数据：DATA LOCAL INPATH '/home/user/test_data/loginmap1.txt' INTO TABLE loginmap;```12345678910111213141516171819202122232425262728293031323334插入数据后表结构如图：![](https://github-pages-1253649638.cos.ap-beijing.myqcloud.com/post-images/2018-02-06-map-1-all.jpg)#### 含脏数据的表处理测试数据：![](https://github-pages-1253649638.cos.ap-beijing.myqcloud.com/post-images/2018-02-06-map-2.jpg)导入数据时可以直接覆盖上一张表：![](https://github-pages-1253649638.cos.ap-beijing.myqcloud.com/post-images/2018-02-06-map-2-all.jpg)在查询某一个键时，因为数据的不统一（如“ wow” 和 “wow”，前者含空格）导致结果不同![](https://github-pages-1253649638.cos.ap-beijing.myqcloud.com/post-images/2018-02-06-map-different-info.jpg)### 结构数据：![](https://github-pages-1253649638.cos.ap-beijing.myqcloud.com/post-images/2018-02-06-struct.jpg)建表：``` sqlCREATE TABLE loginstruct(IP STRING,USRINFO STRUCT&lt;userid:BIGINT, uname:STRING&gt;ROW FORMAT DELIMITED FIELDS TERMINATED BY &apos;,&apos;COLLECTION ITEMS TERMINATED BY &apos;|&apos;; 导入数据：LOAD DATA LOCAL INPATH '/home/user/test_data/login_array/loginstruct.txt' INTO TABLE loginstruct 插入后表信息： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>大数据</category>
        <category>Hive</category>
      </categories>
      <tags>
        <tag>Hive</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 制作词云]]></title>
    <url>%2F2018%2F02%2F02%2Fpython-word-cloud%2F</url>
    <content type="text"><![CDATA[The cloud stood humbly in a corner of the sky. The morning crowner it with splendor.白云谦逊地站在天之一隅，晨光给他戴上了霞彩。 泰戈尔飞鸟集 What is 词云“词云”（Wordle，Word cloud）就是对网络文本中出现频率较高的“关键词”予以视觉上的突出，简单说就是由词汇组成类似云的彩色图片。 准备依赖包网上自动生成词云的网站有很多，在这里使用 “wordcloud” 依赖，功能强大，简单易上手。若需要做中文的词云，需要中文分词工具“jieba ”对文本解析。安装 wordcloud 和 jieba：pip install wordcloud，pip install jieba。如果你安装了多个版本的 Python，则前者默认给Python3安装，若需要给python2 安装 wordcloud，使用 py -2 -m pip install wordcloud。 英文词云这个代码会生成两个词云作为对比，一个是随机颜色，一个是以照片底色为基准颜色的词云。在 WordCloud 方法中，可根据自身需要更改参数以取得最佳效果。 #! python3 from PIL import Image import numpy as np import matplotlib.pyplot as plt from wordcloud import WordCloud, STOPWORDS, ImageColorGenerator text = open('txt/Maraba.txt').read() # 选择文本 alice_coloring = np.array(Image.open("sb.jpg")) # 模板图片 stopwords = set(STOPWORDS) stopwords.add("said") wc = WordCloud(background_color="white", max_words=2000, mask=alice_coloring, stopwords=stopwords, max_font_size=80, min_font_size=5, font_path='CabinSketch-Bold.ttf', random_state=42) wc.generate(text) image_colors = ImageColorGenerator(alice_coloring) plt.imshow(wc, interpolation="bilinear") # 词云颜色随机 plt.axis("off") wc.to_file('sb1.png') # 保存图片到文件 plt.figure() # 新建画布 wc2 = wc.recolor(color_func=image_colors) # 以图片底色作为词云底色 plt.imshow(wc2, interpolation="bilinear") plt.axis("off") wc2.to_file('sb2.png') plt.show() 以下是效果图及对比： 中文词云开始运行行代码的时候，只显式了若干彩色的小矩形框（乱码，Python 的字符编码令人抓狂），中文词语显式不出来，网上搜博客说是 wordcloud 生成词语的字体问题。进入wordcloud.py 的源码，找字体库相关的代码FONT_PATH = os.environ.get("FONT_PATH", os.path.join(os.path.dirname(__file__),"DroidSansMono.ttf"))，将之改为支持中文的字体即可解决。 #! python3 # encoding=utf-8 import numpy as np from PIL import Image import jieba import jieba.analyse as analyse import matplotlib.pyplot as plt from wordcloud import WordCloud, STOPWORDS, ImageColorGenerator alice_coloring = np.array(Image.open("logo1024.jpg")) stopwords = set(STOPWORDS) stopwords.add("said") def chinese(): string = "" with open('hotWords.txt', 'r', encoding='GBK') as f: for i in f: string += i liction = analyse.textrank(string, topK=50, withWeight=True) keywords = {} for word in liction: keywords[word[0]] = word[1] return keywords wc = WordCloud(background_color="white", max_words=2000, mask=alice_coloring, stopwords=stopwords, max_font_size=80, min_font_size=2, #font_path='CabinSketch-Bold.ttf', random_state=42) wc.generate_from_frequencies(chinese()) image_colors = ImageColorGenerator(alice_coloring) plt.imshow(wc.recolor(color_func=image_colors), interpolation="bilinear") plt.axis("off") wc.to_file('weibo_logo1024.jpg') plt.show() 另附：下载微博热搜榜热搜词代码（默认下载三次）。简单的说，这个代码也是一个小爬虫，通过多次刷新热搜榜以获得较多的样本数量，将热搜词爬取下来保存为文本。 #! python3 # -*- coding:utf-8 -*- import time import urllib.request as ulb from bs4 import BeautifulSoup as bs def download(url, proxy=None, num_retries=2): headers = {'User-Agent':'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.6) Gecko/20091201 Firefox/3.5.6'} print ("Downloading: "+url+"...") request = ulb.Request(url=url, headers=headers) time.sleep(1) try: html = ulb.urlopen(request).read() except ulb.URLError as e: print ("Download Error: " + str(e.reason)) html = None if num_retries > 0: if hasattr(e, 'code') and 500 { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>词云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hbase 的安装配置]]></title>
    <url>%2F2018%2F01%2F29%2Fbigdata-hbase%2F</url>
    <content type="text"><![CDATA[Take my wine in my own cup, friend. It lose its wreath of foam when poured into that of others.在我自己的杯中，饮了我的酒吧，朋友。一倒在别人的杯里，这酒的腾跳的泡沫便要消失了。 泰戈尔飞鸟集 环境变量配置在家目录的 “.bashrc” 文件里边配置环境变量，内容应当包括 JDK、Hadoop 和 Hbase。 12345export JAVA_HOME=/home/user/bigdata/jdkexport HADOOP_HOME=/home/user/bigdata/hadoopexport HBASE_HOME=/home/user/bigdata/hbaseexport CLASS_PATH=.:$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/libexport PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$HABASE_HOME/bin:$&#123;PATH&#125; 为了方便操作 hbase，以上已经添加了配置的 Hbase 环境变量： HBASE_HOME （非必须） 配置文件hbase-env.sh 在 hbase/conf 文件夹下，打开 hbase-env.sh，找到 jdk 的路径配置，添加 JAVA_HOME1配置完 jdk 路径后，在下方可以看到配置 HBASE_CLASSPATH 的提示，添加 ```export HBASE_CLASSPATH=/home/user/bigdata/hadoop/etc/hadoop hbase-site.xml 进入编辑模式，在 下添加以下字段： hbase.zookeeper.property.dataDir /home/user/bigdata/zookeeper hbase.cluster.distributed true hbase.rootdir hdfs://localhost:8020/hbase hbase.zookeeper.quorum node-a.example.com,node-b.example.com hbase.zookeeper.property.clientPort 2181 此外，如果应用单独Zookeeper，需发更改/conf/hbase-env.sh下配置参数HBASE_MANAGES_ZK的值为true，即：export HBASE_MANAGES_ZK=true Hbase 启动、停止、监控启动、停止 start-hbase.sh(stop-hbase.sh)，该文件在 hbase/bin 文件夹下，已经添加环境变量，所以可以在任意目录执行。（同 Hadoop） 查看守护进程 jps 命令查看守护进程，有 Hmaster 字样说明启动成功。 浏览器页面查看 在0.98.x以后的 Hbase 版本中，HBase Web UI使用的HTTP端口从主服务器的60010和每个RegionServer的60030更改为主服务器的16010和RegionServer的16030。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>大数据</category>
        <category>HBase</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>Hbase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给 GitHub Pages 博客配置云解析]]></title>
    <url>%2F2018%2F01%2F28%2Fcloud-dns-to-github-pages%2F</url>
    <content type="text"><![CDATA[Thank the flame for its light, but do not fotget the lampholder standing in the shade with coonstancy of patience.谢谢火焰给你光明，但是不要忘了那执灯的人，他是坚忍地站在黑暗当中呢。 泰戈尔飞鸟集 云解析就是绑定域名，这个域名 “moeext.top” 是在阿里云注册的，两块钱😄在 GitHub Pages 上搭好博客之后可以设置云解析。 创建 CNAME 文件首先在博客的根目录新建一个文件：“CNAME”，内容为要解析的域名：“moeext.top”，注意不要添加 http://或 www 等前缀。在 Windows 下如果不能建立没有后缀名的文件时，则可以 shift + 右键打开 Power Shell 输入 echo moeext.top > CNAME以建立该文件。 设置云解析在阿里云的控制台找到 “云解析 DNS” 一栏，在域名下添加解析如下： 设置主机记录www，记录类型为A，记录值是IP192.30.252.153。其中192.30.252.153是Github Pages服务器指定的IP地址，访问该IP地址即表示访问Github Pages 设置主机记录www，记录类型为A，记录值是IP192.30.252.154。 设置主机记录@，记录类型为CNAME，记录值是moeext.github.io.。表示将 http://moeext.top 这个主域名映射到 moeext.github.io 添加完解析之后，等待大约十分钟，你的博客就可以访问了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>GitHub Pages</category>
      </categories>
      <tags>
        <tag>GitHub Pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python SMTP 发送邮件]]></title>
    <url>%2F2018%2F01%2F28%2Fpython-email%2F</url>
    <content type="text"><![CDATA[Like the metting of the seagulls and the waves we meet and come near. The seagulls fly off, the waves roll away and we depart.我们如海鸥之于波涛相遇似的，遇见了，走近了。海鸥飞去，波涛滚滚地流开，我们也分别了。 泰戈尔飞鸟集 模块简介SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。这里发送邮件使用了 smtplib 和 email 两个模块。 发送邮件常用的模块： 12345import smtplibfrom email.header import Headerfrom email.mime.text import MIMETextfrom email.mime.image import MIMEImagefrom email.mime.multipart import MIMEMultipart 语法简介smtplib 模块为发送邮件提供了一种很方便的途径，它对 SMTP 协议进行了简单的封装。其定义的 SMTP 客户端会话对象可使用 SMTP 或 ESMTP 侦听器守护程序向任何互联网机器发送邮件。 创建 smtp 对象的方法是123456* host：SMTP 服务器主机，可指定 IP 或 域名，可选。* port：一般情况下默认端口号为25.* local_hostname：如果 SMTP 服务器在本机上运行，则只需指定服务器地址为 localhost 即可。smtp 对象使用 sendmail 方法发送邮件：```smtp.sendmail(sender, receivers, msg.as_string()) sender：发件人邮箱，字符串 receivers：收件人邮箱，列表 msg：特定格式的邮件 注意：msg是字符串，表示邮件内容。我们知道邮件一般由标题，发信人，收件人，邮件内容，附件等构成，发送邮件的时候，要指定msg的格式。这个格式就是smtp协议中定义的格式。 发送文本格式邮件这里使用新浪邮箱示例，QQ邮箱登录需要16位授权码，而且验证还过不去(lll￢ω￢) # -*- coding: UTF-8 -*- import smtplib from email.mime.text import MIMEText from email.header import Header mail_host="smtp.sina.com" #设置服务器 mail_user="yuwancumiana@sina.cn" #用户名 mail_pass="" #登陆密码 sender = 'yuwancumiana@sina.cn' receivers = ['moeext@gmail.com'] message = MIMEText('从windows发来的一封测试信', 'plain', 'utf-8') # 这里指定邮件内容 message['From'] = "yuwancumiana@sina.cn" message['To'] = "鱼丸粗面" subject = '测试' #主题-title message['Subject'] = Header(subject, 'utf-8') try: smtpObj = smtplib.SMTP() smtpObj.connect(mail_host, 25) smtpObj.login(mail_user,mail_pass) smtpObj.sendmail(sender, receivers, message.as_string()) print u"邮件发送成功" except smtplib.SMTPException as e: print "Error: cannot send my email" print e 接收到的邮件如图： 发送附件# -*- coding: utf-8 -*- import smtplib from email.mime.image import MIMEImage from email.mime.multipart import MIMEMultipart from email.mime.text import MIMEText SMTP_SERVER = 'smtp.sina.com' SMTP_PORT = 25 sender = 'yuwancumiana@sina.cn' recipient = 'moeext@gmail.com' msg = MIMEMultipart() msg['Subject'] = 'Python 附件' msg['To'] = recipient msg['From'] = sender subject = 'Python annex' # 附件1，图片 img = MIMEImage(open(r'img/girl.jpg', 'rb').read(), _subtype='jpg') img.add_header('Content-Disposition', 'attachment', filename = 'Girl.jpg') msg.attach(img) # 附件2，文本 part = MIMEText(open('test.txt','rb').read(), 'plain') # part["Content-Type"] = 'application/octet-stream' part["Content-Disposition"] = 'attachment; filename="test.txt"' part.set_payload("text annex") msg.attach(part) try: session = smtplib.SMTP() session.connect(SMTP_SERVER, 25) ''' session.ehlo() session.starttls() 以TLS加密方式传输，可选 session.ehlo() ''' session.login(sender, 'mq2020.') session.sendmail(sender, recipient, msg.as_string()) print u'发送成功' session.quit() except smtplib.SMTPException,e: print e 效果图： 发送 HTML 附件这里使用的 HTML 是一个小爬虫爬到的数据，经简单包装后返回一个字符串，把字符串作为附件发送。 #!/usr/bin/python #coding:utf-8 import sys import smtplib import traceback import make_html_bs from email.header import Header from email.mime.image import MIMEImage from email.mime.multipart import MIMEMultipart from email.mime.text import MIMEText reload(sys) sys.setdefaultencoding('utf-8') # 第三方 SMTP 服务 mail_host="smtp.sina.com" #设置服务器 mail_user="yuwancumiana@sina.cn" #用户名 mail_pass="" #密码 sender = 'yuwancumiana@sina.cn' receivers = ['yuwancumian666@gmail.com','2535257276@qq.com','635936876@qq.com'] # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 mail = MIMEMultipart("mixed") mail['From'] = "yuwancumiana@sina.cn" mail['To'] = "鱼丸粗面" mail['Subject'] = Header('福利','utf-8') message = MIMEText("今日福利(windows)", 'plain', 'utf-8') mail.attach(message) try: html = make_html_bs.get_html().encode('utf-8') # 这里使用的是另一个爬虫模块返回的数据，为 HTML 格式 except Exception as e: print traceback.print_exc() sys.exit(u"loading pages failed...") HTML = MIMEText(html, _subtype='html', _charset='utf-8') mail.attach(HTML) try: smtp = smtplib.SMTP() smtp.connect(mail_host) smtp.login(mail_user, mail_pass) smtp.sendmail(sender, receivers, mail.as_string()) smtp.close() print u"send mail success" except smtplib.SMTPException,e: print e 结果（你猜猜内容是啥😄）： 总结因为发送邮件的方式（不加密、SSL、TLS、）和类型（附件类型、附件头，附件内容）多种多样，邮件服务器总结起来也非常他喵的麻烦。我之前是做了不少的测试脚本，最后挑了一个经常用的。我对于这个 python 邮件的想法是：能用就成~O(∩_∩)O document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 爬取磁力链]]></title>
    <url>%2F2018%2F01%2F27%2Fcrawling-magnet-links-from-the-pirate-bay%2F</url>
    <content type="text"><![CDATA[The mystery of creation is like the darkness of night——it is great. Delusions of knowledge are like the fog of the morning. 创造的神秘，有如夜间的黑暗，——是伟大的。而知识的幻影，不过是晨间之雾。 泰戈尔飞鸟集 海盗湾简介大名鼎鼎的海盗湾，号称是全银河系最大的 BitTorrent 服务器，拥有数百万资源。是一个专门存储、分类及搜索 BitTorrent 种子文件的 反版权 网站，现今大多资源的提供形式为磁力链 (Magnet)。 设计思想直接构造搜索页面的 url，把要查询的关键字替换掉浏览器查询的关键字，并借此发送请求。由于该网站构造比较简单，可以在搜索界面直接分析，找出磁力链接并进行翻页。 代码使用注意：要搜索的内容需要写到 name_list （列表）里，作为变量传到 main() 模块里。 代码为了美观已将制表符替换为四个空格（页面制表符默认显示8个空格）。 用到的模块 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import osimport reimport timeimport randomimport urlparseimport urllib2 as ulbfrom 4 import BeautifulSoup as '''该模块接受要下载的url、用户代理（默认‘wswp’）、代理服务器（默认为空）和重新尝试次数（默认为2），返回该网页的内容和搜索内容的最大页数（只在第一次返回）。'''def download(url, user_agent='wswp', proxy=None, num_retries=2): print ("Downloading: " + url) headers = {'User-agent': user_agent} request = ulb.Request(url, headers=headers) opener = ulb.build_opener() if proxy: proxy_params = {urlparse.urlparse(url).scheme: proxy} opener.add_handler(ulb.ProxyHandler(proxy_params)) try: html = opener.open(request).read() except ulb.URLError as e: print ("Download Error:" + e.reason) html = None if num_retries > 0: if hasattr(e, 'code') and 500 { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop 的安装]]></title>
    <url>%2F2018%2F01%2F12%2Flinux-hadoop1%2F</url>
    <content type="text"><![CDATA[My heart beats her waves at the shore of the world and writes upon it her signature in tears with the words, “I love thee.”我的心冲激着她的波浪在“世界”的海岸上，蘸着眼泪在上边写着她的题记：“我爱你。” 泰戈尔飞鸟集 大数据与 Hadoop 简单介绍什么是大数据？ 大数据的4V特性：海量的数据规模（volume）、快速的数据流转和动态的数据体系（velocity）、多样的数据类型（variety）和巨大的数据价值（value）。 Hadoop Hadoop 解决的就是 数据的存储（HDFS）和计算分析（MapReduce）的问题。 分布式集群：集群里的每台机器叫一个节点，伪分布式只有一个节点。master 节点负责管理元数据 (Name Node)，slave 负责存储数据 (Data Node)。 保存数据块的信息的数据叫元数据，数据块默认为128MB(Hadoop2)，默认备份3份。 Hadoop 平台的搭建Hadoop 搭建前提：需要安装 jdk 和 SSH 免密。 搭建步骤 上传 Jdk 和 Hadoop 的包到服务器 解压 修改解压后文件夹名，方便以后升级而不用修改环境变量 配置环境变量，路径：用户家目录的 “.bashrc” 123export JAVA_HOME=/home/groot/soft/jdkexport HADOOP_HOME=/home/groot/soft/hadoopexport PATH=$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$&#123;PATH&#125; 修改配置文件，路径 /home/groot/hadoop/etc/hadoop/ A: hadoop-env.sh 找到 “# export JAVA_HOME=${JAVA_HOME}” 字样，在下方修改 jdk 的安装路径 B: core-site.xml 配置访问的主机名和端口 (8020)，fs.default.name hdfs://master:8020 C: hdfs-site 配置备份数，指定元数据和数据块的存储目录 D: 用户名不一样的地方都需要改 E: 配置主机名：/etc/sysconfig/network 文件中，修改为 master/slave F: 配置 IP 和主机名的映射：/etc/hosts 文件，master 和 slave 都要改 G: 配置 SSH 免密，假设在 master 节点家目录的 “.ssh” 文件夹 a: 生成密钥，ssh-keygen -t rsa -p '' b: 这是本机免密，cat id_rsa.pub >> authorized_keys c: 上传公钥到slave，scp id_rsa.pub groot@slave:/home/groot/.ssh/aa.pub d: 免密登陆另一台机器，cat aa.pub >> authorized_keys e: slave 节点重复 master 节点的做法 ./start-all.sh 启动 Hadoop 关闭防火墙（需要 root 权限）：service iptables stop 浏览器访问50070端口进入 HDFS 的管理界面 jps 命令查看进程 主要是查看 Name Node 和 Data Node HDFS 的 shell 命令操作 HDFS 的三种手段 通过客户端管理界面查看 通过 HDFS 的 shell 命令 通过 Java 的 API Shell 命令 执行 Shell 命令的根目录应该是 hdfs:192.168.208.132:8020/，但是我们一般用 / 代替 创建目录：hadoop fs -mkdir 目录名 查看目录：hadoop fs -ls 上传文件：hadoop fs -put 文件名 路径名 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>HDFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux基础]]></title>
    <url>%2F2018%2F01%2F08%2Flinux%2F</url>
    <content type="text"><![CDATA[The sands in your way beg for your aong and your movement, dancing water. Will you carry the burden of their lameness? 跳舞着的流水呀，在你途中的泥沙，要求你的歌声，你的流动呢。你肯挟瘸足的泥沙而俱下么？ 泰戈尔飞鸟集 Linux操作系统简介Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。 Linux的特点： 安全、免费、开源 多用户（完全的，区别于Windows），一个用户的操作不会影响到其他用户 稳定、快速、占用资源少 Java、大数据环境抖默认支持 Linux Linux 的版本 内核版：提供硬件抽象层、硬盘及文件系统控制及多任务功能的系统核心程序。就像手机的安卓系统一样，内核一般无法直接使用 发行版：由 Linux 内核与各种常用软件的集合产品。各个厂商会针对 Linux 内核发布自己的发行版 redHat: 经典红帽系列(RedHat Enterprise Linux, RHEL)，拥有极强的性能与稳定性。好，贵 CentOS: 把 RHEL 重新编译并发布的免费版本，具有广泛的使用人群。好，免费 Fedora: 红帽公司发布的桌面版系统，用户可以免费体验到最新的技术或工具。 openSUSE: 源自德国的一款著名的 Linux 系统，在全球范围内有着不错的声誉及市场占有率。 Gentoo: 具有极高的自定制性，操作复杂，适合具有一定经验的人使用。 Debian: 稳定性、安全性强，提供了免费的基础支持，可以良好地支持各种硬件架构 Ubuntu：派生自 Debian 系列，对新款硬件具有极强的兼容能力。和 Fedora 都是极其出色的桌面系统。 安装 LinuxLinux 可以通过虚拟机 VMware Workstation 安装。虚拟机是能够让用户在一台物理机上模拟出多个操作系统的软件，安装 Linux 前需要设置 CPU 以支持虚拟化。在任务管理器-性能-CPU一栏右下角可以查看当前CPU是否支持虚拟化，若不支持则可去BIOS中设置。 使用虚拟机的优点：不怕折腾，可以方便地还原到出错前的环境状态。 使用Linux 用户root 用户具有最高权限，其他用户直接是安全的 Linux 目录 / 根目录 /bin 存放必要的命令 /boot 存放内核以及启动所需的文件 /dev 存放设备文件 /etc 存放系统配置文件 /home 普通用户的宿主目录，用户数据存放在其主目录中 /lib 存放必要的运行库 /mnt 存放临时的映射文件系统，通常用来挂载使用。/proc 存放存储进程和系统信息 /root 超级用户的主目录 /sbin 存放系统管理程序 /tmp 存放临时文件 /usr 存放应用程序，命令程序文件、程序库、手册和其它文档。 /var 系统默认日志存放目录 远程登陆由于 Linux 在远程服务器上，一般不能直接在上面操作，所以有各种各样的客户端软件用来远程连接 Linux，比如 XShell、MobaXterm等。 连接方法： 要知道 Linux 的 IP 地址、用户名以及对应的密码 虚拟机和本地机要能 ping 通 注意：虚拟机开机是不启动网卡的，需要手动调成自动开机启动。 修改 Nat 连接方式Nat 方式是给虚拟机一个独立的网卡，特点是稳定、IP不变。虚拟机右键 -> 设置 -> 网络适配器 -> 右侧选自定义-vmnet8 -> 保存 虚拟机 -> 编辑 -> 虚拟网络适配器 -> 更改设置 -> 将 net8 改为 NAT 模式 -> 保存 Linux 命令Tip： 命令查询网址 ，此网站仅供参考Tab 键是命令提示 基本语法： 命令名 -选项 参数 cd 切换目录 ，注意区分相对路径和绝对路径的概念1234567cd / 根目录cd ~ 家目录cd a/b/ccd /a/b/ccd .. 返回上级目录cd ../.. 返回上两级目录cd - 返回进入此目录之前所在的目录 ls ll 查看目录12345678910ls 选项 -a 全部 包括隐藏文件 -R 级联显示 ll 详细查询 -h kb显示文件大小``` #### [mkdir](http://man.linuxde.net/mkdir) 创建文件夹``` shellmkdir 创建文件夹 mkdir -p 连续创建多层文件夹 rm 删除文件12345678910rm 删除文件 rm -r 删除文件夹``` #### [cp](http://man.linuxde.net/cp) 复制文件**说明：** cp 命令可以复制到当前目录或其他目录，同时可以修改文件名``` shellcp 要复制的文件名 目标目录/文件名 cp -r 复制目录 mv 移动文件1mv 选项 -参数 touch 创建/更新文件123touch 文件名 已存在的文件名 更新 Linux不分扩展名 vi/vim 文本编辑1234i 写入模式 esc 编辑模式切换到命令模式 :-&gt; wq 保存并退出 :-&gt; q！强制退出 cat 查看文本内容123cat a 查看 a 的内容cat a &gt; b 将 a 的内容给 bcat a &gt;&gt; b 将 a 的内容追加给 b tar 归档压缩12345678两个功能 一个压缩 一个是解压缩 选项 -c 压缩 -x 解压缩 -f 文件 -v 显示 压缩 tar -czvf 压缩后文件名 目标解压缩 tar -xzvf 目标名 -xzvf 目标名 -C 目标目录 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell 编程基础]]></title>
    <url>%2F2018%2F01%2F06%2Flinux-shell%2F</url>
    <content type="text"><![CDATA[The time of life is short; to spend that shortness basely, it would be too long. 人生短暂，若虚度年华，则短暂的人生就太长了。 威廉·莎士比亚 Shell 介绍Shell本身是一种用C语言编写的程序，从用户的角度来看，Shell是用户与Linux操作系统沟通的桥梁。用户既可以输入命令执行，又可以利用 Shell脚本编程，完成更加复杂的操作。在Linux GUI日益完善的今天，在系统管理等领域，Shell编程仍然起着不可忽视的作用。深入地了解和熟练地掌握Shell编程，是每一个Linux用户的必修课。Linux的Shell种类众多，常见的有：Bourne Shell（/usr/bin/sh或/bin/sh）、Bourne Again Shell–Bash（/bin/bash）、C Shell（/usr/bin/csh）等等。每种Shell都有其特点，基本上，掌握其中一种就足够了。在本文中，我们使用的Shell版本是Bash，由于易用和免费，Bash在日常工作中被广泛使用；同时，Bash也是大多数Linux系统默认的Shell。 Shell 基本格式利用vi/vim等文本编辑器编写 Shell 脚本的固定格式如下： 12#!/bin/sh#comments 首行中的符号#!告诉系统其后路径所指定的程序即是解释此脚本文件的Shell程序。如果首行没有这句话，在执行脚本文件的时候，将会出现错误。后续的部分就是主程序，除第一行外，以#开头的行就是注释行，直到此行的结束。如果一行空间不够，可以在行尾加 “ ，这个符号表明下一行与此行会合并为同一行。编辑完毕后，将脚本存盘为 filename.sh，运行前首先将文件属性设为可执行： 12chmod +x filename.sh./finename.sh #本行代码执行脚本 Hello World新学习一门语言的第一步大抵就是 Hello World 了吧，和 C 语言、Java 等不同，Shell 一句话就能做到： 1echo Hello World! 其中 echo 语句要输出的内容可加引号也可不加引号，要输出多个内容时只需将内容依次写出来即可。 变量注意：赋值号两边应该没有空格,否则 num 会被当做一个命令 Shell Script是一种弱类型语言，使用变量的时候无需首先声明其类型。新的变量会在本地数据区分配内存进行存储，这个变量归当前的Shell所有，任何子进程都不能访问本地变量。这些变量与环境变量不同，环境变量被存储在另一内存区，叫做用户环境区，这块内存中的变量可以被子进程访问。 Shell 有两种类型的变量：临时变量：Shell程序内部定义的，作用范围仅限于本程序，对其他程序不可见。包括了用户自定义变量、位置变量。永久变量：永久变量是环境变量，其值不随shell脚本的执行结束而消失。 变量的辅助命令： 1234set #查看系统中所有定义的变量unset 变量名 #删除变量env #用于显示环境变量及其取值export #用于将本地数据区中的变量转移到用户环境区 变量可以直接定义： 12variable_name=variable_valueecho $variable_name # $ 用于取变量的值 $variable_name 可以在引号中使用，这一点和其他高级语言是明显不同的。如果出现混淆的情况，可以用花括号来区分，例如： 12a=hello worldecho "Hi, $as" 就不会输出Hi, hello world，而是输出Hi，。这是因为 Shell 把 $as 当成一个变量，而 $as 未被赋值，其值为空。正确的方法是： echo "Hi, ${a}s 使用单引号，单引号中的变量不会进行变量替换操作。例如： 1234$ABC = “time is $Date”echo $ABC #输出：time is 2013-12-4$ABC = ‘time is $Date’echo $ABC 输出：time is $Date 算术运算1234((i=$j+$k)) # 等价于 i=`expr $j + $k` ((i=$j-$k)) # 等价于 i=`expr $j - $k` ((i=$j*$k)) # 等价于 i=`expr $j * $k` ((i=$j/$k)) # 等价于 i=`expr $j / $k` 条件控制if 语句： 123456if [ 条件 ]; thenelif …; thenelsefi case 语句： 1234case a in "A") ;; *) ;; # 默认情况，相当于C语言的 default esac 与其他语言不同，Shell中if语句的条件部分要以分号来分隔。其中[]表示条件测试，常用的条件测试有下面几种： 123456[ -f "$file" ] #判断$file是否是一个文件[ $a -lt 3 ] #判断$a的值是否小于3，同样-gt和-le分别表示大于或小于等于[ -x "$file" ] #判断$file是否存在且有可执行权限，同样-r测试文件可读性[ -n "$a" ] #判断变量$a是否有值，测试空串用-z[ "$a" = "$b" ] #判断$a和$b的取值是否相等[ cond1 -a cond2 ] #判断cond1和cond2是否同时成立，-o表示cond1和cond2有一成立 要注意条件测试部分中的空格。在方括号的两侧都有空格，在-f、-lt、=等符号两侧同样也有空格。如果没有这些空格，Shell解释脚本的时候就会出错。 数组数组声明和使用的简单用法： 1234array=(a b c)$&#123;array[0]&#125; 通过下标去数组内容$&#123;array[*]&#125; 取所有元素$&#123;#array[*]&#125; 取长度 循环for 循环： 语法1： 1234for n in a b c d do # 代码done 语法2： 1234for((i=0;i&lt;100;i++)) do # 代码done while 循环： 12345678while [ 条件 ] do # 代码done# 注意:在变量自增的时候 # 如果直接 $num+1 字符串拼接num=$(($num+1)) #当数字计算num=$[$num+1] 函数定义函数 1234function 函数名() &#123; 函数体 echo $1 # 取第一个参数&#125; 调用函数: 函数名 参数1 参数2 echo 输出结果; $(函数名取结果) 举个栗子这是代叔的一个练习 1234567891011121314151617181920212223242526272829303132333435363738394041424344function round()&#123; dat=$((`date +"%s%N"`)) echo $&#123;dat:0-8&#125;&#125;function random()&#123; dat=$((`date +"%s%N"`)) num=$(($dat % 10)) num1=$(($num % $(($2 - $1)))) num2=$(($num1 + $1)) echo $num2&#125;function cost()&#123; if [ $1 -le 3 ]; then echo 8 elif [ $1 -gt 3 ]; then num1=$[$1-3] num2=$[$num1*2] num3=$[$num2+8] echo $[$num3] fi&#125;phone1=('137' '192' '135' '155' '188')phone2=`round 00000000 99999999`pho=`random 0 5`phone=$&#123;phone1[$pho]&#125;$phone2mile=`random 1 21`time=$(date +'%Y-%m-%d %H:%M:%S')city=('哈尔滨' '北京' '上海' '大数据')harbin=('香坊区' '道里区' '道外区' '南岗区' )beijing=('海淀区' '朝阳区' '宣武区' '丰台区')shanghai=('奉贤区' '嘉定区' '宝山区' '黄浦区')bigdata=('Java' 'Python' 'Hadoop' 'Linux')money=`cost $mile`len=`random 0 4`len2=`random 0 4`case $len in"0") address1=$&#123;harbin[$len2]&#125;;;"1") address1=$&#123;beijing[$len2]&#125;;;"2") address1=$&#123;shanghai[$len2]&#125;;;"3") address1=$&#123;bigdata[$len2]&#125;;;esacaddress=$&#123;city[$len]&#125;echo Time:$time Phone:$phone Address:$address$address1 Mile:$mile Sum:$money &gt;&gt; Taxi.log document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 进阶]]></title>
    <url>%2F2018%2F01%2F05%2Fdatabase-MySQL%2F</url>
    <content type="text"><![CDATA[My day is done, and I am like a boat drawn on the beach, listening to the dance-music of the tide in the evening.日间的工作完了，于是我像一只托在海滩上的小船，静静地听着晚潮跳舞的乐声。 泰戈尔飞鸟集 基础语法简介数据库（Database）是按照数据结构来组织、存储和管理数据的仓库，是一款高效存储数据和提供分析计算功能的软件。它描述的是数据和信息之间的关系。众所周知，MySQL 为关系型数据库(Relational Database Management System)，这种数据库存储数据的模型称为“关系模型”，这种关系模型将生活中的每种数据抽象成一个表。 表 table 是关系型数据库中基本存储单位 表里有行 row 表里有列 column MySQL所使用的 SQL（结构化查询语言）语言是用于访问数据库的最常用标准化语言。主要分为四类： 分类 说明 关键字 DDL 定义语言 creat DML 操作语言 insert、delete、update DCL 控制语言 grant、remove DQL 查询语言 select 登陆数据库mysql [-D 所选择的数据库名] -h 主机名 -u 用户名 -p，括号中内容可选。 PROMPT 提示符的修改\D | 完整的日期\d | 当前数据库\h | 服务器名称\u | 当前用户 数据库操作create database name | 创建数据库show databases | 查看所有数据库drop database name | 删除某数据库use xxx | 在下文使用某数据库truncate 表明 | 清空表中的记录 表操作create table 表名 (列名 数据类型 约束, 列名1···, ···约束) | 创建表，表名一般是以tb_ 开头drop table 表名 | 删除表alter table 表名 | 添加列add/drop column | 添加/删除行 ####约束 not null | 非空约束unique | 唯一约束primary key | 主键约束foreigner key | 外键约束checked | 检查约束 增删查改（CRUD）插入数据 | insert into 表名 (列名1,列名2,…) values (值1,值2,…); insert into 表名 values (值1,值2,…,值N); insert into 表名 xxx values (),(),();修改数据 | update 表名 set 列名 = 列值 ,列名1=列值1,…;删除数据 | delete from 表名 where; 1234567891011-- 基本查询语法select * from tableName ---- where 子句功能是增加选择条件 select 列名1,... from tb_name where 条件 /*where 的条件&#123; &gt; &lt; &gt;= &lt;= = != &lt;&gt; is null is not null between and in (1,2,3,4) not in (1,2) 并且 and 或者 or&#125;*/ 高级查询模糊查询select * from tb_name where usr_name like ‘条件’ % | 表示任意0个或多个字符。可匹配任意类型和长度的字符 select * from tb_name where usr_name like ‘A%’ 会找出所有名字以‘A’开头的记录，可使用‘and’增加条件_ | 表示任意单个字符，常用来限制表达式的字符长度语句 select * from tb_name where usr_name like ‘b’ 会找出所有名字第二位是‘b’的记录[] | 表示括号内所列字符中的一个 select * from tb_name where usr_name like ‘[a-c]’ 会找出所有名字第二位为‘a、b、c’的记录[^] | 表示不在括号所列之内的单个字符 select * from tb_name where usr_name like ‘_[a-c]’ 会找出所有名字第二位为不是‘a、b、c’的记录 分组查询语法：“group by 要分组的列，”列可以选择多个。一般都和聚合函数搭配使用，而聚合函数可以单独使用。聚合函数： avg()、sum()、max()、min()、count()、group_concat()、select avg(sal)、depto from 表名 group by 列名 注意：查询结果里只能出现被分组的列和聚合的列 排序在查询语句后加 order by 要排序的列 desc(或asc)，其中 desc 为降序，asc 为升序。 分页limit m,n 限制，m=(页码-1)*n，topN 问题：先排序，再分页 去重查询关键字：distinct，去掉重复记录，在select后使用即可。 子查询子查询就是在查询里写查询，一般用于解决一步不能查询求解的问题。其用法非常灵活，几乎可以写在查询的任何位置。语法： 子查询可以写在select后，作为查询结果 子查询可以写在 from 后，作为查询源 子查询可以写在 where 后，作为查询条件 子查询可以使用主查询的资源，子查询要加括号包裹使用 当子查询作为数据源在 from 后时，要起别名 子查询还可以用在 update、insert、delete 里 having 限制条件和 where 的功能一样但是having是可以先分组再过滤，但where是先过滤再分组 表连接表连接的作用是将多个表放在一起查询，解决一个表的数据不满足查询需求的问题。语法：from a, b 需要注意的是，表连接会产生笛卡尔积，使用的时候一定要使用条件加以限制。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
